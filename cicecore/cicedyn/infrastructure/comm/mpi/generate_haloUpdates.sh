#!/bin/sh -f

# This generates HaloUpdate*.subr files for each HaloUpdate method
# and a HaloUpdate_all.subr file for all the subroutines together
# Cut and paste this into ice_boundary.F90
# Note 2DL1 is generated here, but separate, see below

fileall=HaloUpdate_all.subr
echo "generate ${fileall}"
cat <<EOF1 > ${fileall}

!***********************************************************************
EOF1

# generate subroutines

for intfc in 2DR8 2DR4 2DI4 2DL1 3DR8 3DR4 3DI4 4DR8 4DR4 4DI4; do

file=HaloUpdate${intfc}.subr
cdate=`date -u "+%F"`
echo "generate ${file}"

echo "intfc=${intfc}"
if ! [[ ${intfc} =~ 2DL1 ]]; then

  # replacement variables

  xtrdims="error"
  xtrloop="error"
  nzval="error"
  ntval="error"
  if [[ ${intfc} =~ 4D ]]; then
    xtrdims=",:,:"
    xtrloop=",k,l"
    nzval="size(array, dim=3)"
    ntval="size(array, dim=4)"
  elif [[ ${intfc} =~ 3D ]]; then
    xtrdims=",:"
    xtrloop=",k"
    nzval="size(array, dim=3)"
    ntval="1"
  elif [[ ${intfc} =~ 2D ]]; then
    xtrdims=""
    xtrloop=""
    nzval="1"
    ntval="1"
  else
    echo "ERROR, unmatched ${intfc} vs dimension"
    exit -9
  fi

  dtype="error"
  mtype="error"
  zero="error"
  half="error"
  if [[ ${intfc} =~ R8 ]]; then
    dtype="real (dbl_kind)"
    mtype="MPIR8"
    zero="0._dbl_kind"
    half="(0.5_dbl_kind"
  elif [[ ${intfc} =~ R4 ]]; then
    dtype="real (real_kind)"
    mtype="MPIR4"
    zero="0._real_kind"
    half="(0.5_real_kind"
  elif [[ ${intfc} =~ I4 ]]; then
    dtype="integer (int_kind)"
    mtype="MPI_INTEGER"
    zero="0"
    half="nint(0.5_dbl_kind"
  else
    echo "ERROR, unmatched ${intfc} vs type"
    exit -9
  fi

# generate the subroutine

cat <<EOFF > $file

 subroutine ice_HaloUpdate${intfc}(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ${0} on ${cdate}
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   ${dtype}, intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   ${dtype}, dimension(:,:${xtrdims},:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   ${dtype} :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   ${dtype}, dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate${intfc})'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = ${zero}
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = ${nzval}
   nt = ${ntval}

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc${xtrloop},srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi${xtrdims},iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi${xtrdims},iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j${xtrdims},iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j${xtrdims},iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j${xtrdims},iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j${xtrdims},iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j${xtrdims},iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j${xtrdims},iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst${xtrloop},dstBlock) = array(iSrc,jSrc${xtrloop},srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc${xtrloop},srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst${xtrloop},dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst${xtrloop},dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j${xtrdims},iblk) = array(ilo,j${xtrdims},iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j${xtrdims},iblk) = array(ilo,j${xtrdims},iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j${xtrdims},iblk)-array(ilo,j${xtrdims},iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j${xtrdims},iblk) = array(ihi,j${xtrdims},iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j${xtrdims},iblk) = array(ihi,j${xtrdims},iblk) + &
                     real((i),dbl_kind)*(array(ihi,j${xtrdims},iblk)-array(ihi-1,j${xtrdims},iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j${xtrdims},iblk) = array(i,jlo${xtrdims},iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j${xtrdims},iblk) = array(i,jlo${xtrdims},iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1${xtrdims},iblk)-array(i,jlo${xtrdims},iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j${xtrdims},iblk) = array(i,jhi${xtrdims},iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j${xtrdims},iblk) = array(i,jhi${xtrdims},iblk) + &
                     real((j),dbl_kind)*(array(i,jhi${xtrdims},iblk)-array(i,jhi-1${xtrdims},iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = ${half}*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = ${half}*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = ${half}*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = ${half}*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst${xtrloop},dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate${intfc}

EOFF

else   # if intfc eq 2DL1

# generate 2DL1 subroutine

cat <<EOFL > ${file}

 subroutine ice_HaloUpdate2DL1(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.  This routine is the specific interface
!  for 2d horizontal logical arrays.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   logical (log_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   logical (log_kind), dimension(:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) :: &
      istat                ! allocate return status

   integer (int_kind), dimension(:,:,:), allocatable :: &
      iarray               ! array containing field for which halo

   integer (int_kind) :: &
      ifillValue           ! fill value

   character(len=*), parameter :: subname = '(ice_HaloUpdate2DL1)'

!-----------------------------------------------------------------------

   allocate(iarray(size(array,dim=1),size(array,dim=2),size(array,dim=3)),stat=istat)
   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating iarray')
      return
   endif

   iarray = 0
   where (array) iarray = 1
   if (present(fillValue)) then
      ifillValue = 0
      if (fillValue) ifillValue = 1
      call ice_HaloUpdate(iarray, halo,        &
                          fieldLoc, fieldKind, &
                          ifillValue, tripoleOnly)
   else
      call ice_HaloUpdate(iarray, halo,        &
                          fieldLoc, fieldKind, &
                          tripoleOnly=tripoleOnly)
   endif

   ! tcraig, for most BCs, the mod is not needed, iarray will always be 0 or 1.
   ! for neumann, the bc is not a simple copy, it's a computation from neighbor
   ! points.  Use the mod to provide a more consistent result for neumann bcs for
   ! logicals.
   array = .false.
   where (mod(abs(iarray),2) /= 0) array = .true.

   deallocate(iarray, stat=istat)
   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating iarray')
      return
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate2DL1

EOFL

fi  # if intfc ne 2DL1

# cat all subroutines together

cat ${file} >> ${fileall}
cat <<EOF2 >> ${fileall}
!***********************************************************************
EOF2

done    # foreach intfc


exit -9 






