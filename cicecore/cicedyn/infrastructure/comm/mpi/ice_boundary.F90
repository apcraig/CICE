!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

 module ice_boundary

!  This module contains data types and routines for updating halo
!  regions (ghost cells) using MPI calls
!
!  2007-07-19: Phil Jones, Yoshi Yoshida, John Dennis
!              new naming conventions, optimizations during
!              initialization, true multi-dimensional updates
!              (rather than serial call to two-dimensional updates),
!              fixes for non-existent blocks
!  2008-01-28: Elizabeth Hunke replaced old routines with new POP
!              infrastructure
!  2026-02-16: T Craig refactored and added dirichlet and neumann
!              boundary conditions.  ice_HaloUpdate routines
!              generated by code generation script and made 
!              fully compatible with use in serial version.
!
!-----------------------------------------------------------------------
!
! Some notes on tripole, A-H below are gridpoints at i = 1:nx_global
! where nx_global=8.  The schematics below show the general layout of the center
! points on the tripole fold.  More complex pictures are needed to show
! relative orientation and offsets of east, north, and northeast points
! across the fold.  See also appendix E of the NEMO_manual,
! https://zenodo.org/record/6334656#.YiYirhPMLXQ.  Note the NFtype=T
! is the tripole u-fold grid with T-grid=center, U-grid=east, V-grid=north,
! and F-grid=northeast points in CICE.  NFtype=F is similar to tripoleT
! except for the treatment of the poles.  The CICE implementation also
! averages all degenerate points, NEMO's strategy seems to be to copy
! data from one side of the tripole to the other for degenerate points.
!
! tripole: u-fold, fold is on north edge of ny_global
! north and northeast points on the fold are degenerate and averaged
! A,H,D,and E are pole points
!
!   ny_global+2    H   G   F   E   D   C   B   A  @ny_global-1
!   ny_global+1    H   G   F   E   D   C   B   A  @ny_global
!   ny_global      A   B   C   D   E   F   G   H
!   ny_global-1    A   B   C   D   E   F   G   H
!
! tripoleT: t-fold, fold is thru center of ny_global
! center and east points at ny_global are degenerate and averaged
! north and northeast point at ny_global are not prognostic, they are halos
! A and E are pole points
!
!   ny_global+2        H   G   F   E   D   C   B   A  @ny_global-2
!   ny_global+1        H   G   F   E   D   C   B   A  @ny_global-1
!   ny_global      A   BH  CG  DF  E   FD  GC  HB  A
!   ny_global-1    A   B   C   D   E   F   G   H
!   ny_global-2    A   B   C   D   E   F   G   H
!
!-----------------------------------------------------------------------

#ifndef SERIAL_REMOVE_MPI
   use mpi   ! MPI Fortran module
   use ice_communicate, only: mpiR4, mpiR8, mpitagHalo
#endif

   use ice_kinds_mod
   use ice_communicate, only: my_task
   use ice_constants, only: c0, c1, field_type_scalar, &
         field_type_vector, field_type_angle, &
         field_type_unknown, field_type_noupdate, &
         field_loc_center,  field_loc_NEcorner, &
         field_loc_Nface, field_loc_Eface, &
         field_loc_unknown, field_loc_noupdate
   use ice_global_reductions, only: global_maxval
   use ice_exit, only: abort_ice
   use ice_fileunits, only: nu_diag
   use icepack_intfc, only: icepack_warnings_flush, icepack_warnings_aborted

   use ice_blocks, only: nx_block, ny_block, nghost, &
           nblocks_tot, nblocks_x, nblocks_y, ice_blocksNorth, &
           ice_blocksSouth, ice_blocksEast, ice_blocksWest, &
           ice_blocksEast2, ice_blocksWest2, &
           ice_blocksNorthEast, ice_blocksNorthWest, &
           ice_blocksEastNorthEast, ice_blocksWestNorthWest, &
           ice_blocksSouthEast, ice_blocksSouthWest, &
           ice_blocksGetNbrID, get_block_parameter
   use ice_distribution, only: distrb, &
          ice_distributionGetBlockLoc, ice_distributionGet

   implicit none
   private

   type, public :: ice_halo
      integer (int_kind) ::  &
         communicator,     &! communicator to use for update messages
         numLocalBlocks,   &! number of local blocks, needed for halo fill
         numLocalCopies,   &! num local copies for halo update
         tripoleRows        ! number of rows in tripole buffer

      logical (log_kind) ::  &
         tripoleTFlag       ! NS boundary is a tripole T-fold

      integer (int_kind), dimension(:), pointer :: &
         blockGlobalID      ! list of local block global IDs, needed for halo fill

      integer (int_kind), dimension(:,:), pointer :: &
         srcLocalAddr,     &! src addresses for each local copy
         dstLocalAddr       ! dst addresses for each local copy

      character (char_len) :: &
         nsBoundaryType,   &! type of boundary to use in logical ns dir
         ewBoundaryType     ! type of boundary to use in logical ew dir

#ifndef SERIAL_REMOVE_MPI
      integer (int_kind) ::  &
         numMsgSend,       &! number of messages to send halo update
         numMsgRecv         ! number of messages to recv halo update

      integer (int_kind), dimension(:), pointer :: &
         recvTask,         &! task from which to recv each msg
         sendTask,         &! task to   which to send each msg
         sizeSend,         &! size of each sent message
         sizeRecv,         &! size of each recvd message
         tripSend,         &! send msg tripole flag, 0=non-zipper block
         tripRecv           ! recv msg tripole flag, for masked halos

      integer (int_kind), dimension(:,:,:), pointer :: &
         sendAddr,         &! src addresses for each sent message
         recvAddr           ! dst addresses for each recvd message
#endif
   end type

   public :: ice_HaloCreate, &
             ice_HaloMask, &
             ice_HaloUpdate, &
             ice_HaloUpdate_stress, &
             ice_HaloExtrapolate, &
             ice_HaloDestroy

   interface ice_HaloUpdate  ! generic interface
      module procedure ice_HaloUpdate2DR8, &
                       ice_HaloUpdate2DR4, &
                       ice_HaloUpdate2DI4, &
                       ice_HaloUpdate2DL1, &
                       ice_HaloUpdate3DR8, &
                       ice_HaloUpdate3DR4, &
                       ice_HaloUpdate3DI4, &
                       ice_HaloUpdate4DR8, &
                       ice_HaloUpdate4DR4, &
                       ice_HaloUpdate4DI4
   end interface

   interface ice_HaloExtrapolate  ! generic interface
      module procedure ice_HaloExtrapolate2DR8 !, &
!                       ice_HaloExtrapolate2DR4, &  ! not yet
!                       ice_HaloExtrapolate2DI4, &  ! implemented
   end interface

!-----------------------------------------------------------------------
!
!  Buffer size place holders
!
!-----------------------------------------------------------------------

   integer (int_kind) :: &
      bufSizeSend = -1,  &! max buffer size for send messages
      bufSizeRecv = -1,  &! max buffer size for recv messages
      nxGlobal_size = -1  ! global tripole boundary size

!***********************************************************************

contains

!***********************************************************************

 function ice_HaloCreate(dist, nsBoundaryType, ewBoundaryType, &
                         nxGlobal)  result(halo)

!  This routine creates a halo type with info necessary for
!  performing a halo (ghost cell) update. This info is computed
!  based on the input block distribution.

   type (distrb), intent(in) :: &
      dist             ! distribution of blocks across procs

   character (*), intent(in) :: &
      nsBoundaryType,   &! type of boundary to use in logical ns dir
      ewBoundaryType     ! type of boundary to use in logical ew dir

   integer (int_kind), intent(in) :: &
      nxGlobal           ! global grid extent for tripole grids

   type (ice_halo) :: &
      halo               ! a new halo type with info for halo updates

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::             &
      istat,                       &! allocate status flag
      numProcs,                    &! num of processors involved
      communicator,                &! communicator for message passing
      iblock,                      &! block counter
      eastBlock, westBlock,        &! block id  east,  west neighbors
      northBlock, southBlock,      &! block id north, south neighbors
      neBlock, nwBlock,            &! block id northeast, northwest nbrs
      seBlock, swBlock,            &! block id southeast, southwest nbrs
      srcProc, dstProc,            &! source, dest processor locations
      srcLocalID, dstLocalID,      &! local block index of src,dst blocks
      blockSizeX,                  &! size of default physical domain in X
      blockSizeY,                  &! size of default physical domain in Y
      maxTmp,                      &! temp for global maxval
      maxSizeSend, maxSizeRecv,    &! max buffer sizes
      numMsgSend, numMsgRecv,      &! number of messages for this halo
      eastMsgSize, westMsgSize,    &! nominal sizes for e-w msgs
      northMsgSize, southMsgSize,  &! nominal sizes for n-s msgs
      tripoleMsgSize,              &! size for tripole messages
      tripoleMsgSizeOut,           &! size for tripole messages
      tripoleRows,                 &! number of rows in tripole buffer
      cornerMsgSize, msgSize        ! nominal size for corner msg

   integer (int_kind), dimension(:), allocatable :: &
      sendCount, recvCount          ! count number of words to each proc

   logical (log_kind) :: &
      tripoleBlock,         &! flag for identifying north tripole blocks
      tripoleTFlag           ! flag for processing tripole buffer as T-fold

   character(len=*), parameter :: subname = '(ice_HaloCreate)'

!-----------------------------------------------------------------------
!
!  Initialize some useful variables and return if this task not
!  in the current distribution.
!
!-----------------------------------------------------------------------

   call ice_distributionGet(dist,          &
                            nprocs = numProcs,       &
                            communicator = communicator)

   if (my_task >= numProcs) return

   halo%communicator = communicator
   halo%ewBoundaryType = ewBoundaryType
   halo%nsBoundaryType = nsBoundaryType

   blockSizeX = nx_block - 2*nghost
   blockSizeY = ny_block - 2*nghost
   eastMsgSize  = nghost*blockSizeY
   westMsgSize  = nghost*blockSizeY
   southMsgSize = nghost*blockSizeX
   northMsgSize = nghost*blockSizeX
   cornerMsgSize = nghost*nghost
   tripoleRows = nghost+1

   !*** store some block info to fill haloes properly
   call ice_distributionGet(dist, numLocalBlocks=halo%numLocalBlocks)
   if (halo%numLocalBlocks > 0) then
      allocate(halo%blockGlobalID(halo%numLocalBlocks),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating halo%blockGlobalID')
         return
      endif
      call ice_distributionGet(dist, blockGlobalID=halo%blockGlobalID)
   endif

   if (nsBoundaryType == 'tripole' .or. nsBoundaryType == 'tripoleT') then
      tripoleTFlag = (nsBoundaryType == 'tripoleT')
      if (tripoleTflag) tripoleRows = tripoleRows+1
      !*** set tripole message size if not already done
      if (nxGlobal_size < 0) nxGlobal_size = nxGlobal
   else
      tripoleTFlag = .false.
   endif
   halo%tripoleTFlag = tripoleTFlag
   halo%tripoleRows = tripoleRows
   tripoleMsgSize = tripoleRows*blockSizeX
   tripoleMsgSizeOut = tripoleRows*nx_block

!-----------------------------------------------------------------------
!
!  Count the number of messages to send/recv from each processor
!  and number of words in each message.  These quantities are
!  necessary for allocating future arrays.
!
!-----------------------------------------------------------------------

   allocate (sendCount(numProcs), recvCount(numProcs), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating count arrays')
      return
   endif

   sendCount  = 0
   recvCount  = 0

   msgCountLoop: do iblock=1,nblocks_tot

      call ice_distributionGetBlockLoc(dist, iblock, srcProc, &
                                       srcLocalID)

      !*** find north neighbor block and add to message count
      !***  also set tripole block flag for later special cases

      northBlock = ice_blocksGetNbrID(iblock, ice_blocksNorth,        &
                                      ewBoundaryType, nsBoundaryType)
      if (northBlock > 0) then
         tripoleBlock = .false.
         msgSize = northMsgSize
         call ice_distributionGetBlockLoc(dist, northBlock, dstProc, &
                                          dstLocalID)
      else if (northBlock < 0) then ! tripole north row, count block
         tripoleBlock = .true.
         msgSize = tripoleMsgSize
         call ice_distributionGetBlockLoc(dist, abs(northBlock), &
                                 dstProc, dstLocalID)
      else
         tripoleBlock = .false.
         msgSize = northMsgSize
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,           &
                                     srcProc, dstProc, msgSize)

      !*** if a tripole boundary block, also create a local
      !*** message into and out of tripole buffer

      if (tripoleBlock) then
         !*** copy out of tripole buffer - includes halo
         call ice_HaloIncrementMsgCount(sendCount, recvCount,        &
                                        srcProc, srcProc,            &
                                        tripoleMsgSizeOut)

         !*** copy in only required if dstProc not same as srcProc
         if (dstProc /= srcProc) then
            call ice_HaloIncrementMsgCount(sendCount, recvCount,  &
                                           srcProc, srcProc,      &
                                           msgSize)
         endif
      endif

      !*** find south neighbor block and add to message count

      southBlock = ice_blocksGetNbrID(iblock, ice_blocksSouth,        &
                                      ewBoundaryType, nsBoundaryType)

      if (southBlock > 0) then
         call ice_distributionGetBlockLoc(dist, southBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,           &
                                     srcProc, dstProc, southMsgSize)

      !*** find east neighbor block and add to message count

      eastBlock = ice_blocksGetNbrID(iblock, ice_blocksEast,         &
                                     ewBoundaryType, nsBoundaryType)

      if (eastBlock > 0) then
         call ice_distributionGetBlockLoc(dist, eastBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,          &
                                     srcProc, dstProc, eastMsgSize)

      !*** if a tripole boundary block, non-local east neighbor
      !*** needs a chunk of the north boundary, so add a message
      !*** for that
      if (tripoleBlock .and. dstProc /= srcProc) then
         call ice_HaloIncrementMsgCount(sendCount, recvCount,          &
                                     srcProc, dstProc, tripoleMsgSize)
      endif

      !*** find west neighbor block and add to message count

      westBlock = ice_blocksGetNbrID(iblock, ice_blocksWest,         &
                                     ewBoundaryType, nsBoundaryType)

      if (westBlock > 0) then
         call ice_distributionGetBlockLoc(dist, westBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,          &
                                     srcProc, dstProc, westMsgSize)

      !*** if a tripole boundary block, non-local west neighbor
      !*** needs a chunk of the north boundary, so add a message
      !*** for that
      if (tripoleBlock .and. dstProc /= srcProc) then
         call ice_HaloIncrementMsgCount(sendCount, recvCount,          &
                                     srcProc, dstProc, tripoleMsgSize)
      endif

      !*** find northeast neighbor block and add to message count

      neBlock = ice_blocksGetNbrID(iblock, ice_blocksNorthEast,    &
                                   ewBoundaryType, nsBoundaryType)

      if (neBlock > 0) then
         msgSize = cornerMsgSize  ! normal corner message

         call ice_distributionGetBlockLoc(dist, neBlock, dstProc, &
                                          dstLocalID)
      else if (neBlock < 0) then ! tripole north row
         msgSize = tripoleMsgSize  ! tripole needs whole top row of block

         call ice_distributionGetBlockLoc(dist, abs(neBlock), dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,      &
                                     srcProc, dstProc, msgSize)

      !*** find northwest neighbor block and add to message count

      nwBlock = ice_blocksGetNbrID(iblock, ice_blocksNorthWest,    &
                                   ewBoundaryType, nsBoundaryType)

      if (nwBlock > 0) then
         msgSize = cornerMsgSize ! normal NE corner update

         call ice_distributionGetBlockLoc(dist, nwBlock, dstProc, &
                                          dstLocalID)
      else if (nwBlock < 0) then ! tripole north row, count block
         msgSize = tripoleMsgSize ! tripole NE corner update - entire row needed

         call ice_distributionGetBlockLoc(dist, abs(nwBlock), dstProc, &
                                          dstLocalID)

      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,      &
                                     srcProc, dstProc, msgSize)

      !*** find southeast neighbor block and add to message count

      seBlock = ice_blocksGetNbrID(iblock, ice_blocksSouthEast,    &
                                   ewBoundaryType, nsBoundaryType)

      if (seBlock > 0) then
         call ice_distributionGetBlockLoc(dist, seBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,            &
                                     srcProc, dstProc, cornerMsgSize)

      !*** find southwest neighbor block and add to message count

      swBlock = ice_blocksGetNbrID(iblock, ice_blocksSouthWest,    &
                                   ewBoundaryType, nsBoundaryType)

      if (swBlock > 0) then
         call ice_distributionGetBlockLoc(dist, swBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloIncrementMsgCount(sendCount, recvCount,            &
                                     srcProc, dstProc, cornerMsgSize)

#ifndef SERIAL_REMOVE_MPI
      !*** for tripole grids with padded domain, padding will
      !*** prevent tripole buffer from getting all the info
      !*** it needs - must extend footprint at top boundary
      !*** Only needed for multi-proc configurations

      if (tripoleBlock                  .and. & !tripole
          mod(nxGlobal,blockSizeX) /= 0) then   !padding

         !*** find east2 neighbor block and add to message count

         eastBlock = ice_blocksGetNbrID(iBlock, ice_blocksEast2,     &
                                     ewBoundaryType, nsBoundaryType)

         if (eastBlock > 0) then
            call ice_distributionGetBlockLoc(dist, eastBlock, dstProc, &
                                             dstLocalID)
         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloIncrementMsgCount(sendCount, recvCount,       &
                                     srcProc, dstProc, tripoleMsgSize)
         endif

         !*** find EastNorthEast neighbor block and add to message count

         neBlock = ice_blocksGetNbrID(iBlock, ice_blocksEastNorthEast, &
                                     ewBoundaryType, nsBoundaryType)

         if (neBlock < 0) then ! tripole north row
            msgSize = tripoleMsgSize  ! tripole needs whole top row of block

            call ice_distributionGetBlockLoc(dist, abs(neBlock), dstProc, &
                                             dstLocalID)
         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloIncrementMsgCount(sendCount, recvCount,   &
                                        srcProc, dstProc, msgSize)
         endif

         !*** find west2 neighbor block and add to message count

         westBlock = ice_blocksGetNbrID(iBlock, ice_blocksWest2,     &
                                     ewBoundaryType, nsBoundaryType)

         if (westBlock > 0) then
            call ice_distributionGetBlockLoc(dist, westBlock, dstProc, &
                                             dstLocalID)
         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloIncrementMsgCount(sendCount, recvCount,       &
                                     srcProc, dstProc, tripoleMsgSize)
         endif

         !*** find WestNorthWest neighbor block and add to message count

         nwBlock = ice_blocksGetNbrID(iBlock, ice_blocksWestNorthWest, &
                                     ewBoundaryType, nsBoundaryType)

         if (nwBlock < 0) then ! tripole north row
            msgSize = tripoleMsgSize  ! tripole needs whole top row of block

            call ice_distributionGetBlockLoc(dist, abs(nwBlock), dstProc, &
                                             dstLocalID)
         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloIncrementMsgCount(sendCount, recvCount,   &
                                        srcProc, dstProc, msgSize)
         endif

      endif
#endif

   end do msgCountLoop

!-----------------------------------------------------------------------
!
!  if messages are received from the same processor, the message is
!  actually a local copy - count them and reset to zero
!
!-----------------------------------------------------------------------

   halo%numLocalCopies = recvCount(my_task+1)

   sendCount(my_task+1) = 0
   recvCount(my_task+1) = 0

   allocate(halo%srcLocalAddr(3,halo%numLocalCopies), &
            halo%dstLocalAddr(3,halo%numLocalCopies), &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating LocalAddr arrays')
      return
   endif

   halo%srcLocalAddr = 0
   halo%dstLocalAddr = 0

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  now count the number of actual messages to be sent and received
!
!-----------------------------------------------------------------------

   numMsgSend = count(sendCount /= 0)
   numMsgRecv = count(recvCount /= 0)
   halo%numMsgSend = numMsgSend
   halo%numMsgRecv = numMsgRecv

!-----------------------------------------------------------------------
!
!  allocate buffers for 2-d halo updates to save time later
!  if the buffers are already allocated by previous create call,
!   check to see if they need to be re-sized
!
!-----------------------------------------------------------------------

   maxTmp = maxval(sendCount)
   maxSizeSend = global_maxval(maxTmp, dist)
   maxTmp = maxval(recvCount)
   maxSizeRecv = global_maxval(maxTmp, dist)

   bufSizeSend = max(bufSizeSend,maxSizeSend)
   bufSizeRecv = max(bufSizeRecv,maxSizeRecv)

!-----------------------------------------------------------------------
!
!  allocate arrays for message information and initialize
!
!-----------------------------------------------------------------------

   allocate(halo%sendTask(numMsgSend), &
            halo%recvTask(numMsgRecv), &
            halo%sizeSend(numMsgSend), &
            halo%sizeRecv(numMsgRecv), &
            halo%tripSend(numMsgSend), &
            halo%tripRecv(numMsgRecv), &
            halo%sendAddr(3,bufSizeSend,numMsgSend), &
            halo%recvAddr(3,bufSizeRecv,numMsgRecv), &
            stat = istat)

   halo%sendTask = 0
   halo%recvTask = 0
   halo%sizeSend = 0
   halo%sizeRecv = 0
   halo%tripSend = 0
   halo%tripRecv = 0
   halo%sendAddr = 0
   halo%recvAddr = 0
   halo%numMsgSend = 0
   halo%numMsgRecv = 0
#endif

   deallocate(sendCount, recvCount, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating count arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  repeat loop through blocks but this time, determine all the
!  required message information for each message or local copy
!
!-----------------------------------------------------------------------

   !*** reset halo scalars to use as counters

   halo%numLocalCopies = 0

   msgConfigLoop: do iblock=1,nblocks_tot

      call ice_distributionGetBlockLoc(dist, iblock, srcProc, &
                                       srcLocalID)

      !*** find north neighbor block and set msg info
      !***  also set tripole block flag for later special cases

      northBlock = ice_blocksGetNbrID(iblock, ice_blocksNorth,        &
                                      ewBoundaryType, nsBoundaryType)

      if (northBlock > 0) then
         tripoleBlock = .false.
         call ice_distributionGetBlockLoc(dist, northBlock, dstProc, &
                                          dstLocalID)
      else if (northBlock < 0) then ! tripole north row, count block
         tripoleBlock = .true.
         call ice_distributionGetBlockLoc(dist, abs(northBlock), &
                                 dstProc, dstLocalID)
      else
         tripoleBlock = .false.
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloMsgCreate(halo, dist, iblock, northBlock, 'north')

      !*** if a tripole boundary block, also create a local
      !*** message into and out of tripole buffer

      if (tripoleBlock) then
         !*** copy out of tripole buffer - includes halo
         call ice_HaloMsgCreate(halo, dist,-iblock, iblock, 'north')

         !*** copy in only required if dstProc not same as srcProc
         if (dstProc /= srcProc) then
            call ice_HaloMsgCreate(halo, dist, iblock, -iblock, 'north')

         endif
      endif

      !*** find south neighbor block and add to message count

      southBlock = ice_blocksGetNbrID(iblock, ice_blocksSouth,        &
                                      ewBoundaryType, nsBoundaryType)
#if (1 == 0)
      if (southBlock > 0) then
         call ice_distributionGetBlockLoc(dist, southBlock, dstProc, &
                                          dstLocalID)

      else
         dstProc = 0
         dstLocalID = 0
      endif
#endif
      call ice_HaloMsgCreate(halo, dist, iblock, southBlock, 'south')

      !*** find east neighbor block and add to message count

      eastBlock = ice_blocksGetNbrID(iblock, ice_blocksEast,         &
                                     ewBoundaryType, nsBoundaryType)

      if (eastBlock > 0) then
         call ice_distributionGetBlockLoc(dist, eastBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloMsgCreate(halo, dist, iblock, eastBlock, 'east')

      !*** if a tripole boundary block, non-local east neighbor
      !*** needs a chunk of the north boundary, so add a message
      !*** for that

      if (tripoleBlock .and. dstProc /= srcProc) then
         call ice_HaloMsgCreate(halo, dist, iblock, -eastBlock, 'north')
      endif

      !*** find west neighbor block and add to message count

      westBlock = ice_blocksGetNbrID(iblock, ice_blocksWest,         &
                                     ewBoundaryType, nsBoundaryType)

      if (westBlock > 0) then
         call ice_distributionGetBlockLoc(dist, westBlock, dstProc, &
                                          dstLocalID)
      else
         dstProc = 0
         dstLocalID = 0
      endif

      call ice_HaloMsgCreate(halo, dist, iblock, westBlock, 'west')

      !*** if a tripole boundary block, non-local west neighbor
      !*** needs a chunk of the north boundary, so add a message
      !*** for that

      if (tripoleBlock .and. dstProc /= srcProc) then
         call ice_HaloMsgCreate(halo, dist, iblock, -westBlock, 'north')
      endif

      !*** find northeast neighbor block and add to message count

      neBlock = ice_blocksGetNbrID(iblock, ice_blocksNorthEast,    &
                                   ewBoundaryType, nsBoundaryType)

#if (1 == 0)
      if (neBlock /= 0) then
         call ice_distributionGetBlockLoc(dist, abs(neBlock), dstProc, &
                                          dstLocalID)

      else
         dstProc = 0
         dstLocalID = 0
      endif
#endif

      call ice_HaloMsgCreate(halo, dist, iblock, neBlock, 'northeast')

      !*** find northwest neighbor block and add to message count

      nwBlock = ice_blocksGetNbrID(iblock, ice_blocksNorthWest,    &
                                   ewBoundaryType, nsBoundaryType)

#if (1 == 0)
      if (nwBlock /= 0) then
         call ice_distributionGetBlockLoc(dist, abs(nwBlock), dstProc, &
                                          dstLocalID)

      else
         dstProc = 0
         dstLocalID = 0
      endif
#endif

      call ice_HaloMsgCreate(halo, dist, iblock, nwBlock, 'northwest')

      !*** find southeast neighbor block and add to message count

      seBlock = ice_blocksGetNbrID(iblock, ice_blocksSouthEast,    &
                                   ewBoundaryType, nsBoundaryType)

#if (1 == 0)
      if (seBlock > 0) then
         call ice_distributionGetBlockLoc(dist, seBlock, dstProc, &
                                          dstLocalID)

      else
         dstProc = 0
         dstLocalID = 0
      endif
#endif

      call ice_HaloMsgCreate(halo, dist, iblock, seBlock, 'southeast')

      !*** find southwest neighbor block and add to message count

      swBlock = ice_blocksGetNbrID(iblock, ice_blocksSouthWest,    &
                                   ewBoundaryType, nsBoundaryType)
#if (1 == 0)
      if (swBlock > 0) then
         call ice_distributionGetBlockLoc(dist, swBlock, dstProc, &
                                          dstLocalID)

      else
         dstProc = 0
         dstLocalID = 0
      endif
#endif

      call ice_HaloMsgCreate(halo, dist, iblock, swBlock, 'southwest')

#ifndef SERIAL_REMOVE_MPI
      !*** for tripole grids with padded domain, padding will
      !*** prevent tripole buffer from getting all the info
      !*** it needs - must extend footprint at top boundary
      !*** Only needed for multi-proc configurations

      if (tripoleBlock                  .and. & !tripole
          mod(nxGlobal,blockSizeX) /= 0) then   !padding

         !*** find east2 neighbor block and add to message count

         eastBlock = ice_blocksGetNbrID(iBlock, ice_blocksEast2,     &
                                     ewBoundaryType, nsBoundaryType)

         if (eastBlock > 0) then
            call ice_distributionGetBlockLoc(dist, eastBlock, dstProc, &
                                             dstLocalID)

         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloMsgCreate(halo, dist, iblock, -eastBlock, 'north')
         endif

         !*** find EastNorthEast neighbor block and add to message count

         neBlock = ice_blocksGetNbrID(iBlock, ice_blocksEastNorthEast, &
                                     ewBoundaryType, nsBoundaryType)

         if (neBlock < 0) then ! tripole north row
            msgSize = tripoleMsgSize  ! tripole needs whole top row of block

            call ice_distributionGetBlockLoc(dist, abs(neBlock), dstProc, &
                                             dstLocalID)

         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloMsgCreate(halo, dist, iblock, neBlock, 'north')
         endif

         !*** find west2 neighbor block and add to message count

         westBlock = ice_blocksGetNbrID(iBlock, ice_blocksWest2,     &
                                     ewBoundaryType, nsBoundaryType)

         if (westBlock > 0) then
            call ice_distributionGetBlockLoc(dist, westBlock, dstProc, &
                                             dstLocalID)

         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloMsgCreate(halo, dist, iblock, -westBlock, 'north')
         endif

         !*** find WestNorthWest neighbor block and add to message count

         nwBlock = ice_blocksGetNbrID(iBlock, ice_blocksWestNorthWest, &
                                     ewBoundaryType, nsBoundaryType)

         if (nwBlock < 0) then ! tripole north row
            msgSize = tripoleMsgSize  ! tripole needs whole top row of block

            call ice_distributionGetBlockLoc(dist, abs(nwBlock), dstProc, &
                                             dstLocalID)

         else
            dstProc = 0
            dstLocalID = 0
         endif

         if (dstProc /= srcProc) then
            call ice_HaloMsgCreate(halo, dist, iblock, nwBlock, 'north')

         endif

      endif
#endif

   end do msgConfigLoop

!-----------------------------------------------------------------------

 end function ice_HaloCreate

!***********************************************************************

 subroutine ice_HaloMask(halo, basehalo, mask)

!  This routine creates a halo type with info necessary for
!  performing a halo (ghost cell) update. This info is computed
!  based on a base halo already initialized and a mask

   use ice_domain_size, only: max_blocks

   type (ice_halo) :: &
      basehalo           ! basehalo to mask
   integer (int_kind), intent(in) ::  &
      mask(nx_block,ny_block,max_blocks)   ! mask of live points

   type (ice_halo) :: &
      halo               ! a new halo type with info for halo updates

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) :: &
      istat,                    &! allocate status flag
      communicator,             &! communicator for message passing
      numLocalCopies,           &! num local copies for halo update
      numLocalBlocks,           &! num local blocks for halo fill
      tripoleRows                ! number of rows in tripole buffer

   logical (log_kind) :: &
      tripoleTFlag,             &! flag for processing tripole buffer as T-fold
      tmpflag                    ! temporary flag for setting halomask along T-fold

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      n,nmsg,scnt,              &! counters
      icel,jcel,nblock,         &! gridcell index
      numMsgSend, numMsgRecv,   &! number of messages for this halo
      lbufSizeSend,             &! buffer size for send messages
      lbufSizeRecv               ! buffer size for recv messages
#endif

   character(len=*), parameter :: subname = '(ice_HaloMask)'

!-----------------------------------------------------------------------
!
!  allocate and initialize halo
!  halos are not masked for local copies   
!
!-----------------------------------------------------------------------

   communicator   = basehalo%communicator
   tripoleRows    = basehalo%tripoleRows
   tripoleTFlag   = basehalo%tripoleTFlag
   numLocalCopies = basehalo%numLocalCopies
   numLocalBlocks = basehalo%numLocalBlocks

   allocate(halo%srcLocalAddr(3,numLocalCopies), &
            halo%dstLocalAddr(3,numLocalCopies), &
            halo%blockGlobalID(numLocalBlocks), &
            stat = istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating src,dst LocalAddr arrays')
      return
   endif

   halo%communicator   = communicator
   halo%tripoleRows    = tripoleRows
   halo%tripoleTFlag   = tripoleTFlag
   halo%numLocalCopies = numLocalCopies
   halo%numLocalBlocks = numLocalBlocks

   halo%srcLocalAddr   = basehalo%srcLocalAddr(:,1:numLocalCopies)
   halo%dstLocalAddr   = basehalo%dstLocalAddr(:,1:numLocalCopies)

   halo%blockGlobalID  = basehalo%blockGlobalID

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  mask communication part of halo
!  always keep tripole zipper msgs!
!
!-----------------------------------------------------------------------

   numMsgSend     = basehalo%numMsgSend
   numMsgRecv     = basehalo%numMsgRecv
   lbufSizeSend   = size(basehalo%sendAddr,dim=2)
   lbufSizeRecv   = size(basehalo%recvAddr,dim=2)

   allocate(halo%sendTask(numMsgSend), &
            halo%recvTask(numMsgRecv), &
            halo%sizeSend(numMsgSend), &
            halo%sizeRecv(numMsgRecv), &
            halo%tripSend(numMsgSend), &
            halo%tripRecv(numMsgRecv), &
            halo%sendAddr(3,lbufSizeSend,numMsgSend), &
            halo%recvAddr(3,lbufSizeRecv,numMsgRecv), &
            stat = istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating halo send,recv arrays')
      return
   endif

   numMsgSend = 0
   do nmsg=1,basehalo%numMsgSend
      scnt = 0
      do n=1,basehalo%sizeSend(nmsg)
         icel     = basehalo%sendAddr(1,n,nmsg)
         jcel     = basehalo%sendAddr(2,n,nmsg)
         nblock   = basehalo%sendAddr(3,n,nmsg)
! the following line fails bounds check for mask when tripSend /= 0
!        if (mask(icel,jcel,abs(nblock)) /= 0 .or. basehalo%tripSend(nmsg) /= 0) then
         tmpflag = .false.
         if (basehalo%tripSend(nmsg) /= 0) then
            tmpflag = .true.
         elseif (mask(icel,jcel,abs(nblock)) /= 0) then
            tmpflag = .true.
         endif

         if (tmpflag) then
            scnt = scnt + 1
            if (scnt == 1) then
               numMsgSend = numMsgSend + 1
               halo%sendTask(numMsgSend) = basehalo%sendTask(nmsg)
               halo%tripSend(numMsgSend) = basehalo%tripSend(nmsg)
            endif
            halo%sendAddr(1,scnt,numMsgSend) = icel
            halo%sendAddr(2,scnt,numMsgSend) = jcel
            halo%sendAddr(3,scnt,numMsgSend) = nblock
            halo%sizeSend(numMsgSend) = scnt
         endif
      enddo
   enddo
   halo%numMsgSend = numMsgSend

   numMsgRecv = 0
   do nmsg=1,basehalo%numMsgRecv
      scnt = 0
      do n=1,basehalo%sizeRecv(nmsg)
         icel     = basehalo%recvAddr(1,n,nmsg)
         jcel     = basehalo%recvAddr(2,n,nmsg)
         nblock   = basehalo%recvAddr(3,n,nmsg)
! the following line fails bounds check for mask when tripRecv /= 0
!        if (mask(icel,jcel,abs(nblock)) /= 0 .or. basehalo%tripRecv(nmsg) /= 0) then
         tmpflag = .false.
         if (basehalo%tripRecv(nmsg) /= 0) then
            tmpflag = .true.
         elseif (mask(icel,jcel,abs(nblock)) /= 0) then
            tmpflag = .true.
         endif

         if (tmpflag) then
            scnt = scnt + 1
            if (scnt == 1) then
               numMsgRecv = numMsgRecv + 1
               halo%recvTask(numMsgRecv) = basehalo%recvTask(nmsg)
               halo%tripRecv(numMsgRecv) = basehalo%tripRecv(nmsg)
            endif
            halo%recvAddr(1,scnt,numMsgRecv) = icel
            halo%recvAddr(2,scnt,numMsgRecv) = jcel
            halo%recvAddr(3,scnt,numMsgRecv) = nblock
            halo%sizeRecv(numMsgRecv) = scnt
         endif
      enddo
   enddo
   halo%numMsgRecv = numMsgRecv
#endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloMask

!***********************************************************************

 subroutine ice_HaloUpdate2DR8(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (dbl_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   real (dbl_kind), dimension(:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (dbl_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   real (dbl_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate2DR8)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0._dbl_kind
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = 1
   nt = 1

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,dstBlock) = array(iSrc,jSrc,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,iblk) = array(ilo,j,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,iblk) = array(ilo,j,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,iblk)-array(ilo,j,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,iblk) = array(ihi,j,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,iblk) = array(ihi,j,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,iblk)-array(ihi-1,j,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,iblk) = array(i,jlo,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,iblk) = array(i,jlo,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,iblk)-array(i,jlo,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,iblk) = array(i,jhi,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,iblk) = array(i,jhi,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,iblk)-array(i,jhi-1,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate2DR8

!***********************************************************************

 subroutine ice_HaloUpdate2DR4(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (real_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   real (real_kind), dimension(:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (real_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   real (real_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate2DR4)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0._real_kind
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = 1
   nt = 1

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,dstBlock) = array(iSrc,jSrc,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,iblk) = array(ilo,j,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,iblk) = array(ilo,j,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,iblk)-array(ilo,j,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,iblk) = array(ihi,j,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,iblk) = array(ihi,j,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,iblk)-array(ihi-1,j,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,iblk) = array(i,jlo,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,iblk) = array(i,jlo,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,iblk)-array(i,jlo,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,iblk) = array(i,jhi,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,iblk) = array(i,jhi,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,iblk)-array(i,jhi-1,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate2DR4

!***********************************************************************

 subroutine ice_HaloUpdate2DI4(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   integer (int_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   integer (int_kind), dimension(:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   integer (int_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   integer (int_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate2DI4)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = 1
   nt = 1

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,dstBlock) = array(iSrc,jSrc,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,iblk) = array(ilo,j,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,iblk) = array(ilo,j,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,iblk)-array(ilo,j,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,iblk) = array(ihi,j,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,iblk) = array(ihi,j,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,iblk)-array(ihi-1,j,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,iblk) = array(i,jlo,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,iblk) = array(i,jlo,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,iblk)-array(i,jlo,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,iblk) = array(i,jhi,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,iblk) = array(i,jhi,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,iblk)-array(i,jhi-1,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate2DI4

!***********************************************************************

 subroutine ice_HaloUpdate2DL1(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.  This routine is the specific interface
!  for 2d horizontal logical arrays.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   logical (log_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   logical (log_kind), dimension(:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) :: &
      istat                ! allocate return status

   integer (int_kind), dimension(:,:,:), allocatable :: &
      iarray               ! array containing field for which halo

   integer (int_kind) :: &
      ifillValue           ! fill value

   character(len=*), parameter :: subname = '(ice_HaloUpdate2DL1)'

!-----------------------------------------------------------------------

   allocate(iarray(size(array,dim=1),size(array,dim=2),size(array,dim=3)),stat=istat)
   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating iarray')
      return
   endif

   iarray = 0
   where (array) iarray = 1
   if (present(fillValue)) then
      ifillValue = 0
      if (fillValue) ifillValue = 1
      call ice_HaloUpdate(iarray, halo,        &
                          fieldLoc, fieldKind, &
                          ifillValue, tripoleOnly)
   else
      call ice_HaloUpdate(iarray, halo,        &
                          fieldLoc, fieldKind, &
                          tripoleOnly=tripoleOnly)
   endif

   ! tcraig, for most BCs, the mod is not needed, iarray will always be 0 or 1.
   ! for neumann, the bc is not a simple copy, it's a computation from neighbor
   ! points.  Use the mod to provide a more consistent result for neumann bcs for
   ! logicals.
   array = .false.
   where (mod(abs(iarray),2) /= 0) array = .true.

   deallocate(iarray, stat=istat)
   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating iarray')
      return
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate2DL1

!***********************************************************************

 subroutine ice_HaloUpdate3DR8(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (dbl_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   real (dbl_kind), dimension(:,:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (dbl_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   real (dbl_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate3DR8)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0._dbl_kind
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = size(array, dim=3)
   nt = 1

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,k,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,:,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,:,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,:,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,dstBlock) = array(iSrc,jSrc,k,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,k,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,k,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,k,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,iblk) = array(ilo,j,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,:,iblk) = array(ilo,j,:,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,:,iblk)-array(ilo,j,:,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,:,iblk) = array(ihi,j,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,:,iblk) = array(ihi,j,:,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,:,iblk)-array(ihi-1,j,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,iblk) = array(i,jlo,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,:,iblk) = array(i,jlo,:,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,:,iblk)-array(i,jlo,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,:,iblk) = array(i,jhi,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,:,iblk) = array(i,jhi,:,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,:,iblk)-array(i,jhi-1,:,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate3DR8

!***********************************************************************

 subroutine ice_HaloUpdate3DR4(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (real_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   real (real_kind), dimension(:,:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (real_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   real (real_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate3DR4)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0._real_kind
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = size(array, dim=3)
   nt = 1

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,k,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,:,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,:,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,:,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,dstBlock) = array(iSrc,jSrc,k,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,k,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,k,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,k,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,iblk) = array(ilo,j,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,:,iblk) = array(ilo,j,:,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,:,iblk)-array(ilo,j,:,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,:,iblk) = array(ihi,j,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,:,iblk) = array(ihi,j,:,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,:,iblk)-array(ihi-1,j,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,iblk) = array(i,jlo,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,:,iblk) = array(i,jlo,:,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,:,iblk)-array(i,jlo,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,:,iblk) = array(i,jhi,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,:,iblk) = array(i,jhi,:,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,:,iblk)-array(i,jhi-1,:,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate3DR4

!***********************************************************************

 subroutine ice_HaloUpdate3DI4(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   integer (int_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   integer (int_kind), dimension(:,:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   integer (int_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   integer (int_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate3DI4)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = size(array, dim=3)
   nt = 1

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,k,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,:,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,:,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,:,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,dstBlock) = array(iSrc,jSrc,k,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,k,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,k,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,k,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,iblk) = array(ilo,j,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,:,iblk) = array(ilo,j,:,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,:,iblk)-array(ilo,j,:,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,:,iblk) = array(ihi,j,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,:,iblk) = array(ihi,j,:,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,:,iblk)-array(ihi-1,j,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,iblk) = array(i,jlo,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,:,iblk) = array(i,jlo,:,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,:,iblk)-array(i,jlo,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,:,iblk) = array(i,jhi,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,:,iblk) = array(i,jhi,:,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,:,iblk)-array(i,jhi-1,:,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate3DI4

!***********************************************************************

 subroutine ice_HaloUpdate4DR8(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (dbl_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   real (dbl_kind), dimension(:,:,:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (dbl_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   real (dbl_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate4DR8)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0._dbl_kind
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = size(array, dim=3)
   nt = size(array, dim=4)

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,k,l,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,:,:,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,:,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,:,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,:,:,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,:,:,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,l,dstBlock) = array(iSrc,jSrc,k,l,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,k,l,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,k,l,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,k,l,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,:,iblk) = array(ilo,j,:,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,:,:,iblk) = array(ilo,j,:,:,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,:,:,iblk)-array(ilo,j,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,:,:,iblk) = array(ihi,j,:,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,:,:,iblk) = array(ihi,j,:,:,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,:,:,iblk)-array(ihi-1,j,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,:,iblk) = array(i,jlo,:,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,:,:,iblk) = array(i,jlo,:,:,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,:,:,iblk)-array(i,jlo,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,:,:,iblk) = array(i,jhi,:,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,:,:,iblk) = array(i,jhi,:,:,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,:,:,iblk)-array(i,jhi-1,:,:,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,l,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate4DR8

!***********************************************************************

 subroutine ice_HaloUpdate4DR4(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (real_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   real (real_kind), dimension(:,:,:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (real_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   real (real_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate4DR4)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0._real_kind
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = size(array, dim=3)
   nt = size(array, dim=4)

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,k,l,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,:,:,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,:,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,:,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,:,:,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,:,:,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,l,dstBlock) = array(iSrc,jSrc,k,l,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,k,l,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,k,l,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,k,l,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,:,iblk) = array(ilo,j,:,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,:,:,iblk) = array(ilo,j,:,:,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,:,:,iblk)-array(ilo,j,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,:,:,iblk) = array(ihi,j,:,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,:,:,iblk) = array(ihi,j,:,:,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,:,:,iblk)-array(ihi-1,j,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,:,iblk) = array(i,jlo,:,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,:,:,iblk) = array(i,jlo,:,:,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,:,:,iblk)-array(i,jlo,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,:,:,iblk) = array(i,jhi,:,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,:,:,iblk) = array(i,jhi,:,:,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,:,:,iblk)-array(i,jhi-1,:,:,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = (0.5_real_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,l,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate4DR4

!***********************************************************************

 subroutine ice_HaloUpdate4DI4(array, halo,         &
                               fieldLoc, fieldKind, &
                               fillValue, tripoleOnly)

!  Generated by ./generate_haloUpdates.sh on 2026-02-17
!  This is autogenerated so may have some extra code, like k and l
!  loops of length 1 or extra size 1 dimensions in arrays.  This is 
!  done to simply code generation and does not seem to impact performance.

!  This routine updates ghost cells for an input array and is a
!  member of a group of routines under the generic interface
!  ice\_HaloUpdate.

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   integer (int_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   logical (log_kind), intent(in), optional :: &
      tripoleOnly          ! optional flag to execute halo only across tripole seam

   integer (int_kind), dimension(:,:,:,:,:), intent(inout) :: &
      array                ! array containing field for which halo
                           ! needs to be updated

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) ::           &
      i,j,k,l,n,nmsg,     &! dummy loop indices
      ilo,ihi,jlo,jhi,    &! block sizes for fill
      iblk,iblock,jblock, &! global block indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      nz, nt,             &! size of array in 3rd,4th dimensions
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   integer (int_kind) :: &
      fill,               &! value to use for unknown points
      x1,x2,xavg           ! scalars for enforcing symmetry at U pts

   logical (log_kind) :: &
      ewfillouter,        &! fill outer boundary ew
      nsfillouter,        &! fill outer boundary ns
      ltripoleOnly         ! local flag to execute halo only across tripole seam                                                   

   integer (int_kind), dimension(:,:,:,:), allocatable :: &
      bufTripole           ! 4d tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) :: &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of message

   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate4DI4)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   ewfillouter = .true.
   nsfillouter = .true.

   ! do not fill outer boundary if open or closed                                                                               
   if (halo%ewBoundaryType == 'open' .or. &
       halo%ewBoundaryType == 'closed') ewfillouter=.false.
   if (halo%nsBoundaryType == 'open' .or. &
       halo%nsBoundaryType == 'closed') nsfillouter=.false.

   if (present(fillValue)) then
      fill = fillValue
      ! always fill outer boundary if fillValue is passed
      ewfillouter = .true.
      nsfillouter = .true.
   else
      fill = 0
   endif

   if (present(tripoleOnly)) then
      ltripoleOnly = tripoleOnly
   else
      ltripoleOnly = .false.
   endif

   nz = size(array, dim=3)
   nt = size(array, dim=4)

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows,nz,nt),stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole array')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!  allocate send/recv buffers
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend*nz*nt, halo%numMsgSend),   &
            bufRecv(bufSizeRecv*nz*nt, halo%numMsgRecv),   &
            stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating buf arrays')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv
      len = halo%SizeRecv(nmsg)*nz*nt
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8,  &
                     halo%recvTask(nmsg),              &
                     mpitagHalo + halo%recvTask(nmsg), &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend
      i=0
      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         do l=1,nt
         do k=1,nz
            i = i + 1
            bufSend(i,nmsg) = array(iSrc,jSrc,k,l,srcBlock)
         end do
         end do
      end do

      do n=i+1,bufSizeSend*nz*nt
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)*nz*nt
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),             &
                     mpitagHalo + my_task,            &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated, fill out halo region
!  needed for masked halos to ensure halo values are filled for
!  halo grid cells that are not updated except in cases where
!  you don't want to overwrite those halos
!
!-----------------------------------------------------------------------

   if (.not. ltripoleOnly) then
      ! tripoleOnly skip fill, do not overwrite any values in interior as they may
      ! already be set and filling tripole is not necessary

      ! fill outer boundary as needed
      ! only fill corners if both edges are being filled
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)
         if (ewfillouter .or. iblock > 1) then              ! west edge
            do i = 1,nghost
               array(ilo-i,jlo:jhi,:,:,iblk) = fill
            enddo
         endif
         if (ewfillouter .or. iblock < nblocks_x) then      ! east edge
            do i = 1,nghost
               array(ihi+i,jlo:jhi,:,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock > 1) then              ! south edge
            do j = 1,nghost
               array(ilo:ihi,jlo-j,:,:,iblk) = fill
            enddo
         endif
         if (nsfillouter .or. jblock < nblocks_y) then      ! north edge
            do j = 1,nghost
               array(ilo:ihi,jhi+j,:,:,iblk) = fill
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! southwest corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jlo-j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock > 1) .and. &          ! northwest corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ilo-i,jhi+j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! southeast corner
             (nsfillouter .or. jblock > 1)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jlo-j,:,:,iblk) = fill
            enddo
            enddo
         endif
         if ((ewfillouter .or. iblock < nblocks_x) .and. &  ! northeast corner
             (nsfillouter .or. jblock < nblocks_y)) then
            do j = 1,nghost
            do i = 1,nghost
               array(ihi+i,jhi+j,:,:,iblk) = fill
            enddo
            enddo
         endif
      enddo ! iblk
   endif ! tripoleonly
   
!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip
            else
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,l,dstBlock) = array(iSrc,jSrc,k,l,srcBlock)
               end do
               end do
            endif
         else if (dstBlock < 0) then ! tripole copy into buffer
            do l=1,nt
            do k=1,nz
               bufTripole(iDst,jDst,k,l) = array(iSrc,jSrc,k,l,srcBlock)
            end do
            end do
         endif
      else if (srcBlock == 0) then
         if (ltripoleOnly) then
            ! skip
         else
            do l=1,nt
            do k=1,nz
               array(iDst,jDst,k,l,dstBlock) = fill
            end do
            end do
         endif
      endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      i = 0
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock > 0) then
            if (ltripoleOnly) then
               ! skip but still need to advance i counter
               i = i + nt*nz
            else
               do l=1,nt
               do k=1,nz
                  i = i + 1
                  array(iDst,jDst,k,l,dstBlock) = bufRecv(i,nmsg)
               end do
               end do
            endif
         else if (dstBlock < 0) then !tripole
            do l=1,nt
            do k=1,nz
               i = i + 1
               bufTripole(iDst,jDst,k,l) = bufRecv(i,nmsg)
            end do
            end do
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
! Compute dirichlet and neumann BCs
! BCs in corner can be computed in either direction first
! Do full length of edges in both directions to address edge box corners, those halo points will be
! computed independently for each box.  Second pass (north/south) will clean global corners
! Needs to come after halo update because want halo to be filled by other methods (cyclic) first
! before applying dirichlet/neumann in other direction
!
!-----------------------------------------------------------------------

   if (halo%ewBoundaryType == 'dirichlet' .or. halo%ewBoundaryType == 'neumann' .or. &
       halo%nsBoundaryType == 'dirichlet' .or. halo%nsBoundaryType == 'neumann') then
      do iblk = 1, halo%numLocalBlocks
         call get_block_parameter(halo%blockGlobalID(iblk),     &
                                  ilo=ilo,       ihi=ihi,       &
                                  jlo=jlo,       jhi=jhi,       &
                                  iblock=iblock, jblock=jblock)

         if (iblock == 1) then                      ! west edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,:,iblk) = array(ilo,j,:,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann'  ) then
                  array(i,j,:,:,iblk) = array(ilo,j,:,:,iblk) - &
                     real((nghost-i+1),dbl_kind)*(array(ilo+1,j,:,:,iblk)-array(ilo,j,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (iblock == nblocks_x) then              ! east edge
            do j = 1,ny_block
            do i = 1,nghost
               if (halo%ewBoundaryType == 'dirichlet'  ) then
                  array(ihi+i,j,:,:,iblk) = array(ihi,j,:,:,iblk)
               elseif (halo%ewBoundaryType == 'neumann') then
                  array(ihi+i,j,:,:,iblk) = array(ihi,j,:,:,iblk) + &
                     real((i),dbl_kind)*(array(ihi,j,:,:,iblk)-array(ihi-1,j,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == 1) then                      ! south edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,j,:,:,iblk) = array(i,jlo,:,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann'  ) then
                  array(i,j,:,:,iblk) = array(i,jlo,:,:,iblk) - &
                     real((nghost-j+1),dbl_kind)*(array(i,jlo+1,:,:,iblk)-array(i,jlo,:,:,iblk))
               endif
            enddo
            enddo
         endif

         if (jblock == nblocks_y) then              ! north edge
            do j = 1,nghost
            do i = 1,nx_block
               if (halo%nsBoundaryType == 'dirichlet'  ) then
                  array(i,jhi+j,:,:,iblk) = array(i,jhi,:,:,iblk)
               elseif (halo%nsBoundaryType == 'neumann') then
                  array(i,jhi+j,:,:,iblk) = array(i,jhi,:,:,iblk) + &
                     real((j),dbl_kind)*(array(i,jhi,:,:,iblk)-array(i,jhi-1,:,:,iblk))
               endif
            enddo
            enddo
         endif

      enddo  ! iblk
   endif  ! dirichlet or neumann

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top nghost+1 rows (u-fold) or nghost+2 rows
!  (T-fold) of physical domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 2,nxGlobal/2
              iDst = nxGlobal - i + 2
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2 - 1
              iDst = nxGlobal - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case (field_loc_Eface)   ! cell center location

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = 0
           joffset = 1

           !*** top row is degenerate, so must enforce symmetry
           !***   use average of two degenerate points for value

           do l=1,nt
           do k=1,nz
           do i = 1,nxGlobal/2
              iDst = nxGlobal + 1 - i
              x1 = bufTripole(i   ,halo%tripoleRows,k,l)
              x2 = bufTripole(iDst,halo%tripoleRows,k,l)
              xavg = nint(0.5_dbl_kind*(x1 + isign*x2))
              bufTripole(i   ,halo%tripoleRows,k,l) = xavg
              bufTripole(iDst,halo%tripoleRows,k,l) = isign*xavg
           end do
           end do
           end do

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface on u-fold, and NE corner and Nface
            !*** on T-fold, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               do l=1,nt
               do k=1,nz
                  array(iDst,jDst,k,l,dstBlock) = isign*bufTripole(iSrc,jSrc,k,l)
               end do
               end do
            endif

         endif
      end do

   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating send,recv buf arrays')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole array')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate4DI4

!***********************************************************************
!  This routine updates ghost cells for an input array using
!  a second array as needed by the stress fields.
!  This is just like 2DR8 except no averaging and only on tripole

 subroutine ice_HaloUpdate_stress(array1, array2, halo, &
                               fieldLoc, fieldKind,     &
                               fillValue)

   type (ice_halo), intent(in) :: &
      halo                 ! precomputed halo structure containing all
                           !  information needed for halo update

   integer (int_kind), intent(in) :: &
      fieldKind,          &! id for type of field (scalar, vector, angle)
      fieldLoc             ! id for location on horizontal grid
                           !  (center, NEcorner, Nface, Eface)

   real (dbl_kind), intent(in), optional :: &
      fillValue            ! optional value to put in ghost cells
                           !  where neighbor points are unknown
                           !  (e.g. eliminated land blocks or
                           !   closed boundaries)

   real (dbl_kind), dimension(:,:,:), intent(inout) :: &
      array1,             &! array containing field for which halo
                           ! needs to be updated
      array2               ! array containing field for which halo
                           ! in array1 needs to be updated

!  local variables

   integer (int_kind) ::  &
      n,nmsg,             &! dummy loop indices
      istat,              &! allocate status flag
      nxGlobal,           &! global domain size in x (tripole)
      iSrc,jSrc,          &! source addresses for message
      iDst,jDst,          &! dest   addresses for message
      srcBlock,           &! local block number for source
      dstBlock,           &! local block number for destination
      ioffset, joffset,   &! address shifts for tripole
      isign                ! sign factor for tripole grids

   real (dbl_kind) :: &
      fill                 ! value to use for unknown points

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufTripole           ! tripole buffer

#ifndef SERIAL_REMOVE_MPI
   integer (int_kind) ::           &
      ierr,               &! error or status flag for MPI,alloc
      len                  ! length of messages


   integer (int_kind), dimension(:), allocatable :: &
      sndRequest,         &! MPI request ids
      rcvRequest           ! MPI request ids

   integer (int_kind), dimension(:,:), allocatable :: &
      sndStatus,          &! MPI status flags
      rcvStatus            ! MPI status flags

   real (dbl_kind), dimension(:,:), allocatable :: &
      bufSend, bufRecv     ! 4d send,recv buffers
#endif

   character(len=*), parameter :: subname = '(ice_HaloUpdate_stress)'

!-----------------------------------------------------------------------
!
!  abort or return on unknown or noupdate field_loc or field_type
!
!-----------------------------------------------------------------------

   if (fieldLoc  == field_loc_unknown .or. &
       fieldKind == field_type_unknown) then
      call abort_ice(subname//'ERROR: use of field_loc/type_unknown not allowed')
      return
   endif

   if (fieldLoc  == field_loc_noupdate .or. &
       fieldKind == field_type_noupdate) then
      return
   endif

!-----------------------------------------------------------------------
!
!  initialize error code and fill value
!
!-----------------------------------------------------------------------

   if (present(fillValue)) then
      fill = fillValue
   else
      fill = 0.0_dbl_kind
   endif

   nxGlobal = 0
   if (nxGlobal_size > 0) then
      nxGlobal = nxGlobal_size
      allocate(bufTripole(nxGlobal,halo%tripoleRows), stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: allocating bufTripole arrays')
         return
      endif
      bufTripole = fill
   endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  allocate request and status arrays for messages
!
!-----------------------------------------------------------------------

   allocate(sndRequest(halo%numMsgSend), &
            rcvRequest(halo%numMsgRecv), &
            sndStatus(MPI_STATUS_SIZE,halo%numMsgSend), &
            rcvStatus(MPI_STATUS_SIZE,halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating req,status arrays')
      return
   endif

   allocate(bufSend(bufSizeSend, halo%numMsgSend), &
            bufRecv(bufSizeRecv, halo%numMsgRecv), stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: allocating bufSend, bufRecv')
      return
   endif

!-----------------------------------------------------------------------
!
!  post receives
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgRecv

      len = halo%SizeRecv(nmsg)
      call MPI_IRECV(bufRecv(1,nmsg), len, mpiR8, &
                     halo%recvTask(nmsg),               &
                     mpitagHalo + halo%recvTask(nmsg),  &
                     halo%communicator, rcvRequest(nmsg), ierr)
   end do

!-----------------------------------------------------------------------
!
!  fill send buffer and post sends
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numMsgSend

      do n=1,halo%sizeSend(nmsg)
         iSrc     = halo%sendAddr(1,n,nmsg)
         jSrc     = halo%sendAddr(2,n,nmsg)
         srcBlock = halo%sendAddr(3,n,nmsg)

         bufSend(n,nmsg) = array2(iSrc,jSrc,srcBlock)
      end do
      do n=halo%sizeSend(nmsg)+1,bufSizeSend
         bufSend(n,nmsg) = fill  ! fill remainder of buffer
      end do

      len = halo%SizeSend(nmsg)
      call MPI_ISEND(bufSend(1,nmsg), len, mpiR8, &
                     halo%sendTask(nmsg),               &
                     mpitagHalo + my_task,              &
                     halo%communicator, sndRequest(nmsg), ierr)
   end do
#endif

!-----------------------------------------------------------------------
!
!  while messages are being communicated,
!  do NOT zero the halo out, this halo update just updates
!  the tripole zipper as needed for stresses.  if you zero
!  it out, all halo values will be wiped out.
!-----------------------------------------------------------------------
!   do iblk = 1, halo%numLocalBlocks
!      call get_block_parameter(halo%blockGlobalID(iblk), &
!                               ilo=ilo, ihi=ihi,   &
!                               jlo=jlo, jhi=jhi)
!      do j = 1,nghost
!         array(1:nx_block, jlo-j,iblk) = fill
!         array(1:nx_block, jhi+j,iblk) = fill
!      enddo
!      do i = 1,nghost
!         array(ilo-i, 1:ny_block,iblk) = fill
!         array(ihi+i, 1:ny_block,iblk) = fill
!      enddo
!   enddo

!-----------------------------------------------------------------------
!
!  do local copies while waiting for messages to complete
!  if srcBlock is zero, that denotes an eliminated land block or a
!    closed boundary where ghost cell values are undefined
!  if srcBlock is less than zero, the message is a copy out of the
!    tripole buffer and will be treated later
!
!-----------------------------------------------------------------------

   do nmsg=1,halo%numLocalCopies
      iSrc     = halo%srcLocalAddr(1,nmsg)
      jSrc     = halo%srcLocalAddr(2,nmsg)
      srcBlock = halo%srcLocalAddr(3,nmsg)
      iDst     = halo%dstLocalAddr(1,nmsg)
      jDst     = halo%dstLocalAddr(2,nmsg)
      dstBlock = halo%dstLocalAddr(3,nmsg)

      if (srcBlock > 0) then
         if (dstBlock < 0) then ! tripole copy into buffer
            bufTripole(iDst,jDst) = array2(iSrc,jSrc,srcBlock)
         endif
      else if (srcBlock == 0) then
         array1(iDst,jDst,dstBlock) = fill
     endif
   end do

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  wait for receives to finish and then unpack the recv buffer into
!  ghost cells
!
!-----------------------------------------------------------------------

   call MPI_WAITALL(halo%numMsgRecv, rcvRequest, rcvStatus, ierr)

   do nmsg=1,halo%numMsgRecv
      do n=1,halo%sizeRecv(nmsg)
         iDst     = halo%recvAddr(1,n,nmsg)
         jDst     = halo%recvAddr(2,n,nmsg)
         dstBlock = halo%recvAddr(3,n,nmsg)

         if (dstBlock < 0) then !tripole
            bufTripole(iDst,jDst) = bufRecv(n,nmsg)
         endif
      end do
   end do
#endif

!-----------------------------------------------------------------------
!
!  No special code for dirichlet or neumann, only a tripole update
!
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!
!  take care of northern boundary in tripole case
!  bufTripole array contains the top haloWidth+1 rows of physical
!    domain for entire (global) top row
!
!-----------------------------------------------------------------------

   if (nxGlobal > 0) then

      select case (fieldKind)
      case (field_type_scalar)
         isign =  1
      case (field_type_vector)
         isign = -1
      case (field_type_angle)
         isign = -1
      case default
         call abort_ice(subname//'ERROR: Unknown field kind')
      end select

      if (halo%tripoleTFlag) then

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = -1
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 0
           joffset = 1

        case (field_loc_Eface)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_Nface)   ! cell corner (velocity) location

           ioffset = -1
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      else ! tripole u-fold

        select case (fieldLoc)
        case (field_loc_center)   ! cell center location

           ioffset = 0
           joffset = 0

        case (field_loc_NEcorner)   ! cell corner location

           ioffset = 1
           joffset = 1

        case (field_loc_Eface)

           ioffset = 1
           joffset = 0

        case (field_loc_Nface)

           ioffset = 0
           joffset = 1

        case default
           call abort_ice(subname//'ERROR: Unknown field location')
        end select

      endif

      !*** copy out of global tripole buffer into local
      !*** ghost cells

      !*** look through local copies to find the copy out
      !*** messages (srcBlock < 0)

      do nmsg=1,halo%numLocalCopies
         srcBlock = halo%srcLocalAddr(3,nmsg)

         if (srcBlock < 0) then

            iSrc     = halo%srcLocalAddr(1,nmsg) ! tripole buffer addr
            jSrc     = halo%srcLocalAddr(2,nmsg)

            iDst     = halo%dstLocalAddr(1,nmsg) ! local block addr
            jDst     = halo%dstLocalAddr(2,nmsg)
            dstBlock = halo%dstLocalAddr(3,nmsg)

            !*** correct for offsets
            iSrc = iSrc - ioffset
            jSrc = jSrc - joffset
            if (iSrc < 1       ) iSrc = iSrc + nxGlobal
            if (iSrc > nxGlobal) iSrc = iSrc - nxGlobal

            !*** for center and Eface, do not need to replace
            !*** top row of physical domain, so jSrc should be
            !*** out of range and skipped
            !*** otherwise do the copy

            if (jSrc <= halo%tripoleRows .and. jSrc>0 .and. jDst>0) then
               array1(iDst,jDst,dstBlock) = isign*bufTripole(iSrc,jSrc)
            endif

         endif
      end do

   endif

!-----------------------------------------------------------------------
!
!  wait for sends to complete and deallocate arrays
!
!-----------------------------------------------------------------------

#ifndef SERIAL_REMOVE_MPI
   call MPI_WAITALL(halo%numMsgSend, sndRequest, sndStatus, ierr)

   deallocate(sndRequest, rcvRequest, sndStatus, rcvStatus, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating req,status arrays')
      return
   endif

   deallocate(bufSend, bufRecv, stat=istat)

   if (istat > 0) then
      call abort_ice(subname//'ERROR: deallocating bufSend, bufRecv')
      return
   endif
#endif

   if (allocated(bufTripole)) then
      deallocate(bufTripole, stat=istat)
      if (istat > 0) then
         call abort_ice(subname//'ERROR: deallocating bufTripole')
         return
      endif
   endif

!-----------------------------------------------------------------------

 end subroutine ice_HaloUpdate_stress

!***********************************************************************

   subroutine ice_HaloIncrementMsgCount(sndCounter, rcvCounter,    &
                                        srcProc, dstProc, msgSize)

!  This is a utility routine to increment the arrays for counting
!  whether messages are required.  It checks the source and destination
!  task to see whether the current task needs to send, receive or
!  copy messages to fill halo regions (ghost cells).

   integer (int_kind), intent(in) :: &
      srcProc,               &! source processor for communication
      dstProc,               &! destination processor for communication
      msgSize                 ! number of words for this message

   integer (int_kind), dimension(:), intent(inout) :: &
      sndCounter,       &! array for counting messages to be sent
      rcvCounter         ! array for counting messages to be received

   character(len=*), parameter :: subname = '(ice_HaloIncrementMsgCount)'

!-----------------------------------------------------------------------
!
!  error check
!
!-----------------------------------------------------------------------

   if (srcProc < 0 .or. dstProc < 0 .or. &
       srcProc > size(sndCounter)   .or. &
       dstProc > size(rcvCounter)) then
      call abort_ice(subname//'ERROR: invalid processor number')
      return
   endif

!-----------------------------------------------------------------------
!
!  if destination all land or outside closed boundary (dstProc = 0),
!  then no send is necessary, so do the rest only for dstProc /= 0
!
!-----------------------------------------------------------------------

   if (dstProc == 0) return

!-----------------------------------------------------------------------
!
!  if the current processor is the source, must send data
!  local copy if dstProc = srcProc
!
!-----------------------------------------------------------------------

   if (srcProc == my_task + 1) then
      sndCounter(dstProc) = sndCounter(dstProc) + msgSize
   endif

!-----------------------------------------------------------------------
!
!  if the current processor is the destination, must receive data
!  local copy if dstProc = srcProc
!
!-----------------------------------------------------------------------

   if (dstProc == my_task + 1) then

      if (srcProc > 0) then
         !*** the source block has ocean points
         !*** count as a receive from srcProc

         rcvCounter(srcProc) = rcvCounter(srcProc) + msgSize

      else
         !*** if the source block has been dropped, create
         !*** a local copy to fill halo with a fill value

         rcvCounter(dstProc) = rcvCounter(dstProc) + msgSize

      endif
   endif
!-----------------------------------------------------------------------

   end subroutine ice_HaloIncrementMsgCount

!***********************************************************************

   subroutine ice_HaloMsgCreate(halo, dist, srcBlock, dstBlock, direction)

!  This is a utility routine to determine the required address and
!  message information for a particular pair of blocks.

   type (distrb), intent(in) :: &
      dist                    ! distribution of blocks across procs

   integer (int_kind), intent(in) :: &
      srcBlock,   dstBlock    ! source,destination block id

   character (*), intent(in) :: &
      direction               ! direction of neighbor block
                              !  (north,south,east,west,
                              !   and NE, NW, SE, SW)

   type (ice_halo), intent(inout) :: &
      halo                    ! data structure containing halo info

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) :: &
      srcProc, srcLocalID,   &! source block location in distribution
      dstProc, dstLocalID,   &! destination block location in distribution
      msgIndx,               &! message counter and index into msg array
      ibSrc, ieSrc, jbSrc, jeSrc, &! phys domain info for source block
      ibDst, ieDst, jbDst, jeDst, &! phys domain info for dest   block
      nxGlobal,              &! size of global domain in e-w direction
      bufSize,               &! size of message buffer
      i,j,n                   ! dummy loop index

   integer (int_kind), dimension(:), pointer :: &
      iGlobal                 ! global i index for location in tripole

   character(len=*), parameter :: subname = '(ice_HaloMsgCreate)'

!-----------------------------------------------------------------------
!
!  initialize
!
!-----------------------------------------------------------------------

   nxGlobal = nxGlobal_size

!-----------------------------------------------------------------------
!
!  find source and destination block locations
!
!-----------------------------------------------------------------------

   if (srcBlock /= 0) then
      call ice_DistributionGetBlockLoc(dist, abs(srcBlock), srcProc, &
                                       srcLocalID)
   else
      srcProc    = 0
      srcLocalID = 0
   endif

   if (dstBlock /= 0) then
      call ice_DistributionGetBlockLoc(dist, abs(dstBlock), dstProc, &
                                       dstLocalID)
   else
      dstProc    = 0
      dstLocalID = 0
   endif

!-----------------------------------------------------------------------
!
!  if destination all land or outside closed boundary (dstProc = 0),
!  then no send is necessary, so do the rest only for dstProc /= 0
!
!-----------------------------------------------------------------------

   if (dstProc == 0) return

!-----------------------------------------------------------------------
!
!  get block information if either block is local
!
!-----------------------------------------------------------------------

   if (srcProc == my_task+1 .or. dstProc == my_task+1) then

      if (srcBlock >= 0 .and. dstBlock >= 0) then
         call get_block_parameter(srcBlock, &
                                     ilo=ibSrc, ihi=ieSrc,   &
                                     jlo=jbSrc, jhi=jeSrc)
      else ! tripole - need iGlobal info
         call get_block_parameter(abs(srcBlock), &
                                     ilo=ibSrc, ihi=ieSrc,        &
                                     jlo=jbSrc, jhi=jeSrc,        &
                                     i_glob=iGlobal)

      endif

      if (dstBlock /= 0) then
         call get_block_parameter(abs(dstBlock), &
                                     ilo=ibDst, ihi=ieDst,   &
                                     jlo=jbDst, jhi=jeDst)
      endif

   endif

!-----------------------------------------------------------------------
!
!  if both blocks are local, create a local copy to fill halo
!
!-----------------------------------------------------------------------

   if (srcProc == my_task+1 .and. &
       dstProc == my_task+1) then

      !*** compute addresses based on direction

      msgIndx = halo%numLocalCopies

      if (msgIndx > size(halo%srcLocalAddr,dim=2) .or. &
          msgIndx > size(halo%dstLocalAddr,dim=2)) then
         call abort_ice(subname//'ERROR: msg count 1 > array size')
         return
      endif

      select case (direction)
      case ('east')

         !*** copy easternmost physical domain of src
         !*** into westernmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = ieSrc - nghost + i
            halo%srcLocalAddr(2,msgIndx) = jbSrc + j - 1
            halo%srcLocalAddr(3,msgIndx) = srcLocalID

            halo%dstLocalAddr(1,msgIndx) = i
            halo%dstLocalAddr(2,msgIndx) = jbDst + j - 1
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('west')

         !*** copy westernmost physical domain of src
         !*** into easternmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = ibSrc + i - 1
            halo%srcLocalAddr(2,msgIndx) = jbSrc + j - 1
            halo%srcLocalAddr(3,msgIndx) = srcLocalID

            halo%dstLocalAddr(1,msgIndx) = ieDst + i
            halo%dstLocalAddr(2,msgIndx) = jbDst + j - 1
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('north')

         !*** copy northern physical domain of src
         !*** into southern halo of dst

         if (srcBlock > 0 .and. dstBlock > 0) then  ! normal north boundary

            do j=1,nghost
            do i=1,ieSrc-ibSrc+1

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = ibSrc + i - 1
               halo%srcLocalAddr(2,msgIndx) = jeSrc - nghost + j
               halo%srcLocalAddr(3,msgIndx) = srcLocalID

               halo%dstLocalAddr(1,msgIndx) = ibDst + i - 1
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         else if (srcBlock > 0 .and. dstBlock < 0) then

            !*** tripole grid - copy info into tripole buffer
            !*** copy physical domain of top halo+1 rows
            !*** into global buffer at src location

            !*** perform an error check to make sure the
            !*** block has enough points to perform a tripole
            !*** update

            if (jeSrc - jbSrc + 1 < halo%tripoleRows) then
               call abort_ice(subname//'ERROR: not enough points in block for tripole')
               return
            endif

            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = ibSrc + i - 1
               halo%srcLocalAddr(2,msgIndx) = jeSrc-halo%tripoleRows+j
               halo%srcLocalAddr(3,msgIndx) = srcLocalID

               halo%dstLocalAddr(1,msgIndx) = iGlobal(ibSrc + i - 1)
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = -dstLocalID

            end do
            end do

         else if (srcBlock < 0 .and. dstBlock > 0) then

            !*** tripole grid - set up for copying out of
            !*** tripole buffer into ghost cell domains
            !*** include e-w ghost cells

            do j=1,halo%tripoleRows
            do i=1,ieSrc+nghost

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = nxGlobal - iGlobal(i) + 1
               halo%srcLocalAddr(2,msgIndx) = nghost + 3 - j
               halo%srcLocalAddr(3,msgIndx) = -srcLocalID

               halo%dstLocalAddr(1,msgIndx) = i
               if (j.gt.nghost+1) then
                 halo%dstLocalAddr(2,msgIndx) = -1 ! never used
               else
                 halo%dstLocalAddr(2,msgIndx) = jeSrc + j - 1
               endif
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         endif

      case ('south')

         !*** copy southern physical domain of src
         !*** into northern halo of dst

         do j=1,nghost
         do i=1,ieSrc-ibSrc+1

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = ibSrc + i - 1
            halo%srcLocalAddr(2,msgIndx) = jbSrc + j - 1
            halo%srcLocalAddr(3,msgIndx) = srcLocalID

            halo%dstLocalAddr(1,msgIndx) = ibDst + i - 1
            halo%dstLocalAddr(2,msgIndx) = jeDst + j
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('northeast')

         !*** normal northeast boundary - just copy NE corner
         !*** of physical domain into SW halo of NE nbr block

         if (dstBlock > 0) then

            do j=1,nghost
            do i=1,nghost

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = ieSrc - nghost + i
               halo%srcLocalAddr(2,msgIndx) = jeSrc - nghost + j
               halo%srcLocalAddr(3,msgIndx) = srcLocalID

               halo%dstLocalAddr(1,msgIndx) = i
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         else

            !*** tripole grid - this local copy should already
            !*** have taken place for the north boundary

         endif

      case ('northwest')

         !*** normal northeast boundary - just copy NW corner
         !*** of physical domain into SE halo of NW nbr block

         if (dstBlock > 0) then

            do j=1,nghost
            do i=1,nghost

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = ibSrc + i - 1
               halo%srcLocalAddr(2,msgIndx) = jeSrc - nghost + j
               halo%srcLocalAddr(3,msgIndx) = srcLocalID

               halo%dstLocalAddr(1,msgIndx) = ieDst + i
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         else

            !*** tripole grid - this local copy should already
            !*** have taken place for the north boundary

         endif

      case ('southeast')

         !*** copy southeastern corner of src physical domain
         !*** into northwestern halo of dst

         do j=1,nghost
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = ieSrc - nghost + i
            halo%srcLocalAddr(2,msgIndx) = jbSrc + j - 1
            halo%srcLocalAddr(3,msgIndx) = srcLocalID

            halo%dstLocalAddr(1,msgIndx) = i
            halo%dstLocalAddr(2,msgIndx) = jeDst + j
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('southwest')

         !*** copy southwestern corner of src physical domain
         !*** into northeastern halo of dst

         do j=1,nghost
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = ibSrc + i - 1
            halo%srcLocalAddr(2,msgIndx) = jbSrc + j - 1
            halo%srcLocalAddr(3,msgIndx) = srcLocalID

            halo%dstLocalAddr(1,msgIndx) = ieDst + i
            halo%dstLocalAddr(2,msgIndx) = jeDst + j
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case default

         call abort_ice(subname//'ERROR: unknown direction local copy')
         return

      end select

      halo%numLocalCopies = msgIndx

      if (msgIndx > size(halo%srcLocalAddr,dim=2) .or. &
          msgIndx > size(halo%dstLocalAddr,dim=2)) then
         call abort_ice(subname//'ERROR: msg count 2 > array size')
         return
      endif

!-----------------------------------------------------------------------
!
!  if dest block is local and source block does not exist, create a
!  local copy to fill halo with a fill value
!
!-----------------------------------------------------------------------

   else if (srcProc == 0 .and. dstProc == my_task+1) then

      msgIndx = halo%numLocalCopies

      if (msgIndx > size(halo%srcLocalAddr,dim=2) .or. &
          msgIndx > size(halo%dstLocalAddr,dim=2)) then
         call abort_ice(subname//'ERROR: msg count 3 > array size')
         return
      endif

      !*** compute addresses based on direction

      select case (direction)
      case ('east')

         !*** copy easternmost physical domain of src
         !*** into westernmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = 0
            halo%srcLocalAddr(2,msgIndx) = 0
            halo%srcLocalAddr(3,msgIndx) = 0

            halo%dstLocalAddr(1,msgIndx) = i
            halo%dstLocalAddr(2,msgIndx) = jbDst + j - 1
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('west')

         !*** copy westernmost physical domain of src
         !*** into easternmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = 0
            halo%srcLocalAddr(2,msgIndx) = 0
            halo%srcLocalAddr(3,msgIndx) = 0

            halo%dstLocalAddr(1,msgIndx) = ieDst + i
            halo%dstLocalAddr(2,msgIndx) = jbDst + j - 1
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('north')

         !*** copy northern physical domain of src
         !*** into southern halo of dst

         if (dstBlock > 0) then  ! normal north boundary

            do j=1,nghost
            do i=1,ieSrc-ibSrc+1

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = 0
               halo%srcLocalAddr(2,msgIndx) = 0
               halo%srcLocalAddr(3,msgIndx) = 0

               halo%dstLocalAddr(1,msgIndx) = ibDst + i - 1
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         endif

      case ('south')

         !*** copy southern physical domain of src
         !*** into northern halo of dst

         do j=1,nghost
         do i=1,ieSrc-ibSrc+1

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = 0
            halo%srcLocalAddr(2,msgIndx) = 0
            halo%srcLocalAddr(3,msgIndx) = 0

            halo%dstLocalAddr(1,msgIndx) = ibDst + i - 1
            halo%dstLocalAddr(2,msgIndx) = jeDst + j
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('northeast')

         !*** normal northeast boundary - just copy NE corner
         !*** of physical domain into SW halo of NE nbr block

         if (dstBlock > 0) then

            do j=1,nghost
            do i=1,nghost

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = 0
               halo%srcLocalAddr(2,msgIndx) = 0
               halo%srcLocalAddr(3,msgIndx) = 0

               halo%dstLocalAddr(1,msgIndx) = i
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         endif

      case ('northwest')

         !*** normal northeast boundary - just copy NW corner
         !*** of physical domain into SE halo of NW nbr block

         if (dstBlock > 0) then

            do j=1,nghost
            do i=1,nghost

               msgIndx = msgIndx + 1

               halo%srcLocalAddr(1,msgIndx) = 0
               halo%srcLocalAddr(2,msgIndx) = 0
               halo%srcLocalAddr(3,msgIndx) = 0

               halo%dstLocalAddr(1,msgIndx) = ieDst + i
               halo%dstLocalAddr(2,msgIndx) = j
               halo%dstLocalAddr(3,msgIndx) = dstLocalID

            end do
            end do

         endif

      case ('southeast')

         !*** copy southeastern corner of src physical domain
         !*** into northwestern halo of dst

         do j=1,nghost
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = 0
            halo%srcLocalAddr(2,msgIndx) = 0
            halo%srcLocalAddr(3,msgIndx) = 0

            halo%dstLocalAddr(1,msgIndx) = i
            halo%dstLocalAddr(2,msgIndx) = jeDst + j
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case ('southwest')

         !*** copy southwestern corner of src physical domain
         !*** into northeastern halo of dst

         do j=1,nghost
         do i=1,nghost

            msgIndx = msgIndx + 1

            halo%srcLocalAddr(1,msgIndx) = 0
            halo%srcLocalAddr(2,msgIndx) = 0
            halo%srcLocalAddr(3,msgIndx) = 0

            halo%dstLocalAddr(1,msgIndx) = ieDst + i
            halo%dstLocalAddr(2,msgIndx) = jeDst + j
            halo%dstLocalAddr(3,msgIndx) = dstLocalID

         end do
         end do

      case default

         call abort_ice(subname//'ERROR: unknown direction local copy')
         return

      end select

      halo%numLocalCopies = msgIndx

      if (msgIndx > size(halo%srcLocalAddr,dim=2) .or. &
          msgIndx > size(halo%dstLocalAddr,dim=2)) then
         call abort_ice(subname//'ERROR: msg count 4 > array size')
         return
      endif

#ifndef SERIAL_REMOVE_MPI
!-----------------------------------------------------------------------
!
!  if source block local and dest block remote, send a message
!
!-----------------------------------------------------------------------

   else if (srcProc == my_task+1 .and. &
            dstProc /= my_task+1 .and. dstProc > 0) then

      !*** first check to see if a message to this processor has
      !*** already been defined
      !*** if not, update counters and indices

      msgIndx = 0

      srchSend: do n=1,halo%numMsgSend
         if (halo%sendTask(n) == dstProc - 1) then
            msgIndx = n
            bufSize = halo%sizeSend(n)
            exit srchSend
         endif
      end do srchSend

      if (msgIndx == 0) then
         msgIndx = halo%numMsgSend + 1
         halo%numMsgSend = msgIndx
         halo%sendTask(msgIndx) = dstProc - 1
         bufSize = 0
      endif

      !*** now compute message info based on msg direction

      select case (direction)
      case ('east')

         !*** send easternmost physical domain of src
         !*** into westernmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            bufSize = bufSize + 1

            halo%sendAddr(1,bufSize,msgIndx) = ieSrc - nghost + i
            halo%sendAddr(2,bufSize,msgIndx) = jbSrc + j - 1
            halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

         end do
         end do

         halo%sizeSend(msgIndx) = bufSize

      case ('west')

         !*** copy westernmost physical domain of src
         !*** into easternmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            bufSize = bufSize + 1

            halo%sendAddr(1,bufSize,msgIndx) = ibSrc + i - 1
            halo%sendAddr(2,bufSize,msgIndx) = jbSrc + j - 1
            halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

         end do
         end do

         halo%sizeSend(msgIndx) = bufSize

      case ('north')

         if (dstBlock > 0) then

            !*** copy northern physical domain of src
            !*** into southern halo of dst

            do j=1,nghost
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%sendAddr(1,bufSize,msgIndx) = ibSrc + i - 1
               halo%sendAddr(2,bufSize,msgIndx) = jeSrc-nghost+j
               halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

            end do
            end do

            halo%sizeSend(msgIndx) = bufSize

         else

            !*** tripole block - send top halo%tripoleRows rows of phys domain

            halo%tripSend(msgIndx) = 1
            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%sendAddr(1,bufSize,msgIndx)=ibSrc + i - 1
               halo%sendAddr(2,bufSize,msgIndx)=jeSrc-halo%tripoleRows+j
               halo%sendAddr(3,bufSize,msgIndx)=srcLocalID

            end do
            end do

            halo%sizeSend(msgIndx) = bufSize

         endif

      case ('south')

         !*** copy southern physical domain of src
         !*** into northern halo of dst

         do j=1,nghost
         do i=1,ieSrc-ibSrc+1

            bufSize = bufSize + 1

            halo%sendAddr(1,bufSize,msgIndx) = ibSrc + i - 1
            halo%sendAddr(2,bufSize,msgIndx) = jbSrc + j - 1
            halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

         end do
         end do

         halo%sizeSend(msgIndx) = bufSize

      case ('northeast')


         if (dstBlock > 0) then

            !*** normal northeast corner
            !*** copy northeast corner of src physical domain
            !*** into southwestern halo of dst

            do j=1,nghost
            do i=1,nghost

               bufSize = bufSize + 1

               halo%sendAddr(1,bufSize,msgIndx) = ieSrc-nghost+i
               halo%sendAddr(2,bufSize,msgIndx) = jeSrc-nghost+j
               halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

            end do
            end do

            halo%sizeSend(msgIndx) = bufSize

         else

            !*** tripole block - send top halo%tripoleRows rows of phys domain

            halo%tripSend(msgIndx) = 1
            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%sendAddr(1,bufSize,msgIndx)=ibSrc + i - 1
               halo%sendAddr(2,bufSize,msgIndx)=jeSrc-halo%tripoleRows+j
               halo%sendAddr(3,bufSize,msgIndx)=srcLocalID

            end do
            end do

            halo%sizeSend(msgIndx) = bufSize

         endif

      case ('northwest')

         if (dstBlock > 0) then

            !*** normal northwest corner
            !*** copy northwest corner of src physical domain
            !*** into southeastern halo of dst

            do j=1,nghost
            do i=1,nghost

               bufSize = bufSize + 1

               halo%sendAddr(1,bufSize,msgIndx) = ibSrc + i - 1
               halo%sendAddr(2,bufSize,msgIndx) = jeSrc-nghost+j
               halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

            end do
            end do

            halo%sizeSend(msgIndx) = bufSize

         else

            !*** tripole block - send top halo%tripoleRows rows of phys domain

            halo%tripSend(msgIndx) = 1
            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%sendAddr(1,bufSize,msgIndx)=ibSrc + i - 1
               halo%sendAddr(2,bufSize,msgIndx)=jeSrc-halo%tripoleRows+j
               halo%sendAddr(3,bufSize,msgIndx)=srcLocalID

            end do
            end do

            halo%sizeSend(msgIndx) = bufSize

         endif

      case ('southeast')

         !*** copy southeastern corner of src physical domain
         !*** into northwestern halo of dst

         do j=1,nghost
         do i=1,nghost

            bufSize = bufSize + 1

            halo%sendAddr(1,bufSize,msgIndx) = ieSrc - nghost + i
            halo%sendAddr(2,bufSize,msgIndx) = jbSrc + j - 1
            halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

         end do
         end do

         halo%sizeSend(msgIndx) = bufSize

      case ('southwest')

         !*** copy southwestern corner of src physical domain
         !*** into northeastern halo of dst

         do j=1,nghost
         do i=1,nghost

            bufSize = bufSize + 1

            halo%sendAddr(1,bufSize,msgIndx) = ibSrc + i - 1
            halo%sendAddr(2,bufSize,msgIndx) = jbSrc + j - 1
            halo%sendAddr(3,bufSize,msgIndx) = srcLocalID

         end do
         end do

         halo%sizeSend(msgIndx) = bufSize

      case default

         !*** already checked in previous case construct

      end select

!-----------------------------------------------------------------------
!
!  if source block remote and dest block local, recv a message
!
!-----------------------------------------------------------------------

   else if (dstProc == my_task+1 .and. &
            srcProc /= my_task+1 .and. srcProc > 0) then

      !*** first check to see if a message from this processor has
      !*** already been defined
      !*** if not, update counters and indices

      msgIndx = 0

      srchRecv: do n=1,halo%numMsgRecv
         if (halo%recvTask(n) == srcProc - 1) then
            msgIndx = n
            bufSize = halo%sizeRecv(n)
            exit srchRecv
         endif
      end do srchRecv

      if (msgIndx == 0) then
         msgIndx = halo%numMsgRecv + 1
         halo%numMsgRecv = msgIndx
         halo%recvTask(msgIndx) = srcProc - 1
         bufSize = 0
      endif

      !*** now compute message info based on msg direction

      select case (direction)
      case ('east')

         !*** send easternmost physical domain of src
         !*** into westernmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            bufSize = bufSize + 1

            halo%recvAddr(1,bufSize,msgIndx) = i
            halo%recvAddr(2,bufSize,msgIndx) = jbDst + j - 1
            halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

         end do
         end do

         halo%sizeRecv(msgIndx) = bufSize

      case ('west')

         !*** copy westernmost physical domain of src
         !*** into easternmost halo of dst

         do j=1,jeSrc-jbSrc+1
         do i=1,nghost

            bufSize = bufSize + 1

            halo%recvAddr(1,bufSize,msgIndx) = ieDst + i
            halo%recvAddr(2,bufSize,msgIndx) = jbDst + j - 1
            halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

         end do
         end do

         halo%sizeRecv(msgIndx) = bufSize

      case ('north')

         if (dstBlock > 0) then

            !*** copy northern physical domain of src
            !*** into southern halo of dst

            do j=1,nghost
            do i=1,ieDst-ibDst+1

               bufSize = bufSize + 1

               halo%recvAddr(1,bufSize,msgIndx) = ibDst + i - 1
               halo%recvAddr(2,bufSize,msgIndx) = j
               halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

            end do
            end do

            halo%sizeRecv(msgIndx) = bufSize

         else

            !*** tripole block - receive into tripole buffer

            halo%tripRecv(msgIndx) = 1
            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%recvAddr(1,bufSize,msgIndx) = iGlobal(ibSrc + i - 1)
               halo%recvAddr(2,bufSize,msgIndx) = j
               halo%recvAddr(3,bufSize,msgIndx) = -dstLocalID

            end do
            end do

            halo%sizeRecv(msgIndx) = bufSize

         endif

      case ('south')

         !*** copy southern physical domain of src
         !*** into northern halo of dst

         do j=1,nghost
         do i=1,ieSrc-ibSrc+1

            bufSize = bufSize + 1

            halo%recvAddr(1,bufSize,msgIndx) = ibDst + i - 1
            halo%recvAddr(2,bufSize,msgIndx) = jeDst + j
            halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

         end do
         end do

         halo%sizeRecv(msgIndx) = bufSize

      case ('northeast')

         if (dstBlock > 0) then

            !*** normal northeast neighbor
            !*** copy northeast physical domain into
            !*** into southwest halo of dst

            do j=1,nghost
            do i=1,nghost

               bufSize = bufSize + 1

               halo%recvAddr(1,bufSize,msgIndx) = i
               halo%recvAddr(2,bufSize,msgIndx) = j
               halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

            end do
            end do

            halo%sizeRecv(msgIndx) = bufSize

         else

            !*** tripole block - receive into tripole buffer

            halo%tripRecv(msgIndx) = 1
            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%recvAddr(1,bufSize,msgIndx) = iGlobal(ibSrc + i - 1)
               halo%recvAddr(2,bufSize,msgIndx) = j
               halo%recvAddr(3,bufSize,msgIndx) = -dstLocalID

            end do
            end do

            halo%sizeRecv(msgIndx) = bufSize

         endif

      case ('northwest')

         if (dstBlock > 0) then

            !*** normal northwest neighbor
            !*** copy northwest physical domain into
            !*** into southeast halo of dst

            do j=1,nghost
            do i=1,nghost

               bufSize = bufSize + 1

               halo%recvAddr(1,bufSize,msgIndx) = ieDst + i
               halo%recvAddr(2,bufSize,msgIndx) = j
               halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

            end do
            end do

            halo%sizeRecv(msgIndx) = bufSize

         else

            !*** tripole block - receive into tripole buffer

            halo%tripRecv(msgIndx) = 1
            do j=1,halo%tripoleRows
            do i=1,ieSrc-ibSrc+1

               bufSize = bufSize + 1

               halo%recvAddr(1,bufSize,msgIndx) = iGlobal(ibSrc + i - 1)
               halo%recvAddr(2,bufSize,msgIndx) = j
               halo%recvAddr(3,bufSize,msgIndx) = -dstLocalID

            end do
            end do

            halo%sizeRecv(msgIndx) = bufSize

         endif

      case ('southeast')

         !*** copy southeastern corner of src physical domain
         !*** into northwestern halo of dst

         do j=1,nghost
         do i=1,nghost

            bufSize = bufSize + 1

            halo%recvAddr(1,bufSize,msgIndx) = i
            halo%recvAddr(2,bufSize,msgIndx) = jeDst + j
            halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

         end do
         end do

         halo%sizeRecv(msgIndx) = bufSize

      case ('southwest')

         !*** copy southwestern corner of src physical domain
         !*** into northeastern halo of dst

         do j=1,nghost
         do i=1,nghost

            bufSize = bufSize + 1

            halo%recvAddr(1,bufSize,msgIndx) = ieDst + i
            halo%recvAddr(2,bufSize,msgIndx) = jeDst + j
            halo%recvAddr(3,bufSize,msgIndx) = dstLocalID

         end do
         end do

         halo%sizeRecv(msgIndx) = bufSize

      case default

         !*** already checked in previous case construct

      end select
#endif

!-----------------------------------------------------------------------
!
!  if none of the cases above, no message info required for this
!  block pair
!
!-----------------------------------------------------------------------

   endif

!-----------------------------------------------------------------------

   end subroutine ice_HaloMsgCreate

!***********************************************************************

 subroutine ice_HaloExtrapolate2DR8(ARRAY,dist,ew_bndy_type,ns_bndy_type)

!  This subroutine extrapolates ARRAY values into the ghost cells,
!  and is intended for grid variables whose ghost cells
!  would otherwise be set using the default boundary conditions (Dirichlet
!  or Neumann).
!
!  This is the specific interface for double precision arrays
!  corresponding to the generic interface ice_HaloExtrapolate
!
!  T.Craig, Oct 2025 - extend to nghost > 1

   use ice_blocks, only: block, nblocks_x, nblocks_y, get_block
   use ice_constants, only: c2
   use ice_distribution, only: ice_distributionGetBlockID

   character (char_len) :: &
       ew_bndy_type,    &! type of domain bndy in each logical
       ns_bndy_type      !    direction (ew is i, ns is j)

   type (distrb), intent(in) :: &
      dist                 ! block distribution for array X

   real (dbl_kind), dimension(:,:,:), intent(inout) :: &
     ARRAY          ! array containing distributed field

!-----------------------------------------------------------------------
!
!  local variables
!
!-----------------------------------------------------------------------

   integer (int_kind) :: &
     i,j,n,iblk,ii,jj,   &! dummy loop indices
     ilo,ihi,jlo,jhi,    &! active block indices
     numBlocks,          &! number of local blocks
     blockID,            &! block location
     ibc                  ! ghost cell column or row

   type (block) :: &
     this_block  ! block info for current block

   character(len=*), parameter :: subname = '(ice_HaloExtrapolate2DR8)'

!-----------------------------------------------------------------------
!
!  Linear extrapolation
!
!-----------------------------------------------------------------------

   call ice_distributionGet(dist, &
                            numLocalBlocks = numBlocks)

   do iblk = 1, numBlocks
      call ice_distributionGetBlockID(dist, iblk, blockID)
      this_block = get_block(blockID, blockID)
      ilo = this_block%ilo
      ihi = this_block%ihi
      jlo = this_block%jlo
      jhi = this_block%jhi

      if (this_block%iblock == 1) then              ! west edge
         if (trim(ew_bndy_type) /= 'cyclic') then
            do n = 1, nghost
            ii = ilo - n  ! gridcell to extrapolate to
            do j = 1, ny_block
               ARRAY(ii,j,iblk) = c2*ARRAY(ii+1,j,iblk) - ARRAY(ii+2,j,iblk)
            enddo
            enddo
         endif
      endif

      if (this_block%iblock == nblocks_x) then  ! east edge
         if (trim(ew_bndy_type) /= 'cyclic') then
            do n = 1, nghost
            ii = ihi + n  ! gridcell to extrapolate to
            do j = 1, ny_block
               ARRAY(ii,j,iblk) = c2*ARRAY(ii-1,j,iblk) - ARRAY(ii-2,j,iblk)
            enddo
            enddo
         endif
      endif

      if (this_block%jblock == 1) then              ! south edge
         if (trim(ns_bndy_type) /= 'cyclic') then
            do n = 1, nghost
            jj = jlo - n  ! gridcell to extrapolate to
            do i = 1, nx_block
               ARRAY(i,jj,iblk) = c2*ARRAY(i,jj+1,iblk) - ARRAY(i,jj+2,iblk)
            enddo
            enddo
         endif
      endif

      if (this_block%jblock == nblocks_y) then  ! north edge
         if (trim(ns_bndy_type) /= 'cyclic' .and. &
             trim(ns_bndy_type) /= 'tripole' .and. &
             trim(ns_bndy_type) /= 'tripoleT' ) then
            do n = 1, nghost
            jj = jhi + n  ! gridcell to extrapolate to
            do i = 1, nx_block
               ARRAY(i,jj,iblk) = c2*ARRAY(i,jj-1,iblk) - ARRAY(i,jj-2,iblk)
            enddo
            enddo
         endif
      endif

   enddo ! iblk

!-----------------------------------------------------------------------

 end subroutine ice_HaloExtrapolate2DR8

!***********************************************************************

 subroutine ice_HaloDestroy(halo)

!  This routine creates a halo type with info necessary for
!  performing a halo (ghost cell) update. This info is computed
!  based on the input block distribution.

   type (ice_halo) :: &
      halo               ! a new halo type with info for halo updates

   integer (int_kind) :: &
      istat              ! error or status flag for MPI,alloc

   character(len=*), parameter :: subname = '(ice_HaloDestroy)'
!-----------------------------------------------------------------------

   deallocate(halo%srcLocalAddr, &
              halo%dstLocalAddr, &
              halo%blockGlobalID, stat=istat)

   if (istat > 0) then
      call abort_ice(subname,' ERROR: deallocating src,dst')
      return
   endif

#ifndef SERIAL_REMOVE_MPI
   deallocate(halo%sendTask, &
              halo%recvTask, &
              halo%sizeSend, &
              halo%sizeRecv, &
              halo%tripSend, &
              halo%tripRecv, &
              halo%sendAddr, &
              halo%recvAddr, stat=istat)

   if (istat > 0) then
      call abort_ice(subname,' ERROR: deallocating send,recv')
      return
   endif
#endif

end subroutine ice_HaloDestroy

!***********************************************************************

end module ice_boundary

!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
